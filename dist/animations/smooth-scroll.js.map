{
  "version": 3,
  "sources": ["../../bin/live-reload.js", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/attrs.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/constants.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/is.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/contains.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/env.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/data-url.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/platform.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/event.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/get-by-id.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/sanitize.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/get-by-text.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/get-by-typeahead.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/get-computed-style.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/get-parent-node.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/get-scroll-position.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/tabbable.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/initial-focus.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/is-editable-element.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/is-hidden-element.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/is-overflow-element.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/raf.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/observe-attributes.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/observe-children.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/overflow.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/proxy-tab-focus.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/query.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/scope.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/scroll-into-view.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/set.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/visually-hidden.ts", "../../node_modules/.pnpm/@zag-js+dom-query@0.65.1/node_modules/@zag-js/dom-query/src/wait-for.ts", "../../node_modules/.pnpm/@zag-js+remove-scroll@0.65.1/node_modules/@zag-js/remove-scroll/src/index.ts", "../../node_modules/.pnpm/lenis@1.1.3/node_modules/lenis/src/maths.js", "../../node_modules/.pnpm/lenis@1.1.3/node_modules/lenis/src/animate.js", "../../node_modules/.pnpm/lenis@1.1.3/node_modules/lenis/src/dimensions.js", "../../node_modules/.pnpm/lenis@1.1.3/node_modules/lenis/src/debounce.js", "../../node_modules/.pnpm/lenis@1.1.3/node_modules/lenis/src/emitter.js", "../../node_modules/.pnpm/lenis@1.1.3/node_modules/lenis/src/virtual-scroll.js", "../../node_modules/.pnpm/lenis@1.1.3/node_modules/lenis/src/index.ts", "../../src/utils/constants.ts", "../../src/animations/smooth-scroll.ts"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener('change', () => location.reload());\r\n", "import type { Booleanish } from \"./types\"\n\nexport const dataAttr = (guard: boolean | undefined) => (guard ? \"\" : undefined) as Booleanish\nexport const ariaAttr = (guard: boolean | undefined) => (guard ? \"true\" : undefined)\n", "export const MAX_Z_INDEX = 2147483647\n", "const ELEMENT_NODE: typeof Node.ELEMENT_NODE = 1\nconst DOCUMENT_NODE: typeof Node.DOCUMENT_NODE = 9\nconst DOCUMENT_FRAGMENT_NODE: typeof Node.DOCUMENT_FRAGMENT_NODE = 11\n\nconst isObject = (v: unknown): v is Record<string, unknown> => typeof v === \"object\" && v !== null\n\nexport const isHTMLElement = (el: any): el is HTMLElement =>\n  isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === \"string\"\n\nexport const isDocument = (el: any): el is Document => isObject(el) && el.nodeType === DOCUMENT_NODE\n\nexport const isWindow = (el: any): el is Window => isObject(el) && el === el.window\n\nexport const isVisualViewport = (el: any): el is VisualViewport =>\n  isObject(el) && el.constructor.name === \"VisualViewport\"\n\nexport const getNodeName = (node: Node | Window): string => {\n  if (isHTMLElement(node)) return node.localName || \"\"\n  return \"#document\"\n}\n\nexport function isRootElement(node: Node): boolean {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node))\n}\n\nexport const isNode = (el: any): el is Node => isObject(el) && el.nodeType !== undefined\n\nexport const isShadowRoot = (el: any): el is ShadowRoot =>\n  isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in el\n", "import { isHTMLElement } from \"./is\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n", "import { isHTMLElement, isDocument, isShadowRoot, isWindow } from \"./is\"\n\nexport function getDocument(el: Element | Window | Node | Document | null) {\n  if (isDocument(el)) return el\n  if (isWindow(el)) return el.document\n  return el?.ownerDocument ?? document\n}\n\nexport function getDocumentElement(el: Element | Node | Window | Document | null): HTMLElement {\n  return getDocument(el).documentElement\n}\n\nexport function getWindow(el: Node | ShadowRoot | Document | undefined) {\n  if (isShadowRoot(el)) return getWindow(el.host)\n  if (isDocument(el)) return el.defaultView ?? window\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window\n  return window\n}\n\nexport function getActiveElement(el: HTMLElement): HTMLElement | null {\n  const doc = getDocument(el)\n  let activeElement = doc.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n", "import { getWindow } from \"./env\"\n\nexport type DataUrlType = \"image/png\" | \"image/jpeg\" | \"image/svg+xml\"\n\nexport interface DataUrlOptions {\n  type: DataUrlType\n  quality?: number\n}\n\nexport function getDataUrl(svg: SVGElement | undefined | null, opts: DataUrlOptions): Promise<string> {\n  const { type, quality = 0.92 } = opts\n\n  if (!svg) throw new Error(\"[get-data-url]: could not find the svg element\")\n\n  const win = getWindow(svg)\n  const doc = win.document\n\n  const serializer = new win.XMLSerializer()\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svg)\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source)\n\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString)\n  }\n\n  const svgBounds = svg.getBoundingClientRect()\n  const dpr = win.devicePixelRatio || 1\n\n  const canvas = doc.createElement(\"canvas\")\n  const image = new win.Image()\n  image.src = svgString\n\n  canvas.width = svgBounds.width * dpr\n  canvas.height = svgBounds.height * dpr\n\n  const context = canvas.getContext(\"2d\")\n  context!.scale(dpr, dpr)\n\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context!.drawImage(image, 0, 0)\n      resolve(canvas.toDataURL(type, quality))\n    }\n  })\n}\n", "export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/)\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => pt(/iP(hone|ad|od)|iOS/)\nexport const isWebKit = () => ua(/AppleWebKit/)\n\nexport const isModKey = (event: Pick<KeyboardEvent, \"metaKey\" | \"ctrlKey\">) =>\n  isApple() ? event.metaKey : event.ctrlKey\n", "import { contains } from \"./contains\"\nimport { isApple } from \"./platform\"\n\nexport function getBeforeInputValue(event: Pick<InputEvent, \"currentTarget\">) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget as HTMLInputElement\n  return value.slice(0, selectionStart!) + (event as any).data + value.slice(selectionEnd!)\n}\n\nfunction getComposedPath(event: any): EventTarget[] | undefined {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.()\n}\n\nexport function getEventTarget<T extends EventTarget>(\n  event: Partial<Pick<UIEvent, \"target\" | \"composedPath\">>,\n): T | null {\n  const composedPath = getComposedPath(event)\n  return (composedPath?.[0] ?? event.target) as T | null\n}\n\nexport const isSelfTarget = (event: Partial<Pick<UIEvent, \"currentTarget\" | \"target\" | \"composedPath\">>) => {\n  return contains(event.currentTarget as Node, getEventTarget(event))\n}\n\nexport function isOpeningInNewTab(event: Pick<MouseEvent, \"currentTarget\" | \"metaKey\" | \"ctrlKey\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const isAppleDevice = isApple()\n  if (isAppleDevice && !event.metaKey) return false\n  if (!isAppleDevice && !event.ctrlKey) return false\n\n  const localName = element.localName\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isDownloadingEvent(event: Pick<MouseEvent, \"altKey\" | \"currentTarget\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const localName = element.localName\n  if (!event.altKey) return false\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isComposingEvent(event: any) {\n  return event.nativeEvent?.isComposing ?? event.isComposing\n}\n", "export type ItemToId<T> = (v: T) => string\n\nexport const defaultItemToId = <T extends HTMLElement>(v: T) => v.id\n\nexport function itemById<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  const item = itemById(v, id, itemToId)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n", "export const sanitize = (str: string) =>\n  str\n    .split(\"\")\n    .map((char) => {\n      const code = char.charCodeAt(0)\n      if (code > 0 && code < 128) return char\n      if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\")\n      return \"\"\n    })\n    .join(\"\")\n    .trim()\n", "import { defaultItemToId, indexOfId, type ItemToId } from \"./get-by-id\"\nimport { sanitize } from \"./sanitize\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\")\n\nconst match = (valueText: string, query: string) => valueText.trim().toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(\n  v: T[],\n  text: string,\n  currentId?: string | null,\n  itemToId: ItemToId<T> = defaultItemToId,\n) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n", "import { getByText } from \"./get-by-text\"\nimport type { ItemToId } from \"./get-by-id\"\n\nexport interface TypeaheadState {\n  keysSoFar: string\n  timer: number\n}\n\nexport interface TypeaheadOptions {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n  itemToId?: ItemToId<HTMLElement>\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350, itemToId } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId, itemToId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n", "import { getWindow } from \"./env\"\n\nconst styleCache = new WeakMap<Element, CSSStyleDeclaration>()\n\nexport function getComputedStyle(el: Element) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el))\n  }\n  return styleCache.get(el)!\n}\n", "import { getDocumentElement } from \"./env\"\nimport { getNodeName, isShadowRoot } from \"./is\"\n\nexport function getParentNode(node: Node): Node {\n  if (getNodeName(node) === \"html\") {\n    return node\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as any).assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) ||\n    // Fallback.\n    getDocumentElement(node)\n\n  return isShadowRoot(result) ? result.host : result\n}\n", "import { isHTMLElement } from \"./is\"\n\nexport interface ScrollPosition {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function getScrollPosition(element: HTMLElement | Window): ScrollPosition {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop }\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY }\n}\n", "const isHTMLElement = (element: any): element is HTMLElement =>\n  typeof element === \"object\" && element !== null && element.nodeType === 1\n\nconst isFrame = (element: any): element is HTMLIFrameElement => isHTMLElement(element) && element.tagName === \"IFRAME\"\n\nfunction isVisible(el: any) {\n  if (!isHTMLElement(el)) return false\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0\n}\n\ntype IncludeContainerType = boolean | \"if-empty\"\n\nfunction hasNegativeTabIndex(element: Element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10)\n  return tabIndex < 0\n}\n\nconst focusableSelector =\n  /*#__PURE__*/ \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" +\n  \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" +\n  \"iframe, object, embed, area[href], audio[controls], video[controls], \" +\n  \"[contenteditable]:not([contenteditable='false']), details > summary:first-of-type\"\n\n/**\n * Returns the focusable elements within the element\n */\nexport const getFocusables = (\n  container: Pick<HTMLElement, \"querySelectorAll\"> | null,\n  includeContainer: IncludeContainerType = false,\n) => {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n\n  const include = includeContainer == true || (includeContainer == \"if-empty\" && elements.length === 0)\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container)\n  }\n\n  const focusableElements = elements.filter(isFocusable)\n\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      focusableElements.splice(i, 1, ...getFocusables(frameBody))\n    }\n  })\n\n  return focusableElements\n}\n\n/**\n * Whether this element is focusable\n */\nexport function isFocusable(element: HTMLElement | null): element is HTMLElement {\n  if (!element || element.closest(\"[inert]\")) return false\n  return element.matches(focusableSelector) && isVisible(element)\n}\n\nexport function getFirstFocusable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getFocusables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the tabbable elements within the element\n */\nexport function getTabbables(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n  const tabbableElements = elements.filter(isTabbable)\n\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container)\n  }\n\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      const allFrameTabbable = getTabbables(frameBody)\n      tabbableElements.splice(i, 1, ...allFrameTabbable)\n    }\n  })\n\n  if (!tabbableElements.length && includeContainer) {\n    return elements\n  }\n\n  return tabbableElements\n}\n\n/**\n * Whether this element is tabbable\n */\nexport function isTabbable(el: HTMLElement | null): el is HTMLElement {\n  if (el != null && el.tabIndex > 0) return true\n  return isFocusable(el) && !hasNegativeTabIndex(el)\n}\n\n/**\n * Returns the first focusable element within the element\n */\nexport function getFirstTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getTabbables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the last focusable element within the element\n */\nexport function getLastTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const elements = getTabbables(container, includeContainer)\n  return elements[elements.length - 1] || null\n}\n\n/**\n * Returns the first and last focusable elements within the element\n */\nexport function getTabbableEdges(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): [HTMLElement, HTMLElement] | [null, null] {\n  const elements = getTabbables(container, includeContainer)\n  const first = elements[0] || null\n  const last = elements[elements.length - 1] || null\n  return [first, last]\n}\n\n/**\n * Returns the next tabbable element after the current element\n */\nexport function getNextTabbable(container: HTMLElement | null, current?: HTMLElement | null): HTMLElement | null {\n  const tabbables = getTabbables(container)\n  const doc = container?.ownerDocument || document\n  const currentElement = current ?? (doc.activeElement as HTMLElement | null)\n  if (!currentElement) return null\n  const index = tabbables.indexOf(currentElement)\n  return tabbables[index + 1] || null\n}\n", "import { getTabbableEdges, getTabbables } from \"./tabbable\"\n\nexport interface InitialFocusOptions {\n  root: HTMLElement | null\n  getInitialEl?: () => HTMLElement | null\n  enabled?: boolean\n  filter?: (el: HTMLElement) => boolean\n}\n\nexport function getInitialFocus(options: InitialFocusOptions): HTMLElement | undefined {\n  const { root, getInitialEl, filter, enabled = true } = options\n\n  if (!enabled) return\n\n  let node: HTMLElement | null | undefined = null\n\n  node ||= typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl\n  node ||= root?.querySelector<HTMLElement>(\"[data-autofocus],[autofocus]\")\n\n  if (!node) {\n    const tabbables = getTabbables(root)\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0]\n  }\n\n  return node || root || undefined\n}\n\nexport function isValidTabEvent(event: Pick<KeyboardEvent, \"shiftKey\" | \"currentTarget\">): boolean {\n  const container = event.currentTarget as HTMLElement | null\n  if (!container) return false\n\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container)\n  const doc = container.ownerDocument || document\n\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false\n  if (!firstTabbable && !lastTabbable) return false\n\n  return true\n}\n", "import { getWindow } from \"./env\"\nimport { isHTMLElement } from \"./is\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = getWindow(el)\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n", "export function isHiddenElement(node: HTMLElement) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true\n  return node.hidden\n}\n", "import { getWindow } from \"./env\"\n\nconst OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/\n\nexport function isOverflowElement(el: HTMLElement): boolean {\n  const win = getWindow(el)\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el)\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display)\n}\n", "export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n", "import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveAttributeOptions {\n  attributes: string[]\n  callback(record: MutationRecord): void\n  defer?: boolean\n}\n\nfunction observeAttributesImpl(node: MaybeElement, options: ObserveAttributeOptions) {\n  if (!node) return\n  const { attributes, callback: fn } = options\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change)\n      }\n    }\n  })\n  obs.observe(node, { attributes: true, attributeFilter: attributes })\n  return () => obs.disconnect()\n}\n\nexport function observeAttributes(nodeOrFn: NodeOrFn, options: ObserveAttributeOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeAttributesImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveChildrenOptions {\n  callback: MutationCallback\n  defer?: boolean\n}\n\nfunction observeChildrenImpl(node: MaybeElement, options: ObserveChildrenOptions) {\n  const { callback: fn } = options\n  if (!node) return\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver(fn)\n  obs.observe(node, { childList: true, subtree: true })\n  return () => obs.disconnect()\n}\n\nexport function observeChildren(nodeOrFn: NodeOrFn, options: ObserveChildrenOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeChildrenImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { getDocument, getWindow } from \"./env\"\nimport { getParentNode } from \"./get-parent-node\"\nimport { isHTMLElement, isRootElement, isVisualViewport } from \"./is\"\nimport { isOverflowElement } from \"./is-overflow-element\"\n\nexport type OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getNearestOverflowAncestor(el: Node): HTMLElement {\n  const parentNode = getParentNode(el)\n\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode\n  }\n\n  return getNearestOverflowAncestor(parentNode)\n}\n\nexport function getOverflowAncestors(el: HTMLElement, list: OverflowAncestor = []): OverflowAncestor {\n  const scrollableAncestor = getNearestOverflowAncestor(el)\n  const isBody = scrollableAncestor === el.ownerDocument.body\n  const win = getWindow(scrollableAncestor)\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []))\n}\n\nconst getRect = (el: HTMLElement | Window | VisualViewport) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect()\n  }\n\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width }\n  }\n\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth }\n}\n\nexport function isInView(el: HTMLElement | Window | VisualViewport, ancestor: HTMLElement | Window | VisualViewport) {\n  if (!isHTMLElement(el)) return true\n\n  const ancestorRect = getRect(ancestor)\n  const elRect = el.getBoundingClientRect()\n\n  return (\n    elRect.top >= ancestorRect.top &&\n    elRect.left >= ancestorRect.left &&\n    elRect.bottom <= ancestorRect.bottom &&\n    elRect.right <= ancestorRect.right\n  )\n}\n", "import { raf } from \"./raf\"\nimport { getNextTabbable, getTabbableEdges } from \"./tabbable\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\ninterface ProxyTabFocusOptions<T = MaybeElement> {\n  triggerElement?: T\n  onFocus?: (elementToFocus: HTMLElement) => void\n  defer?: boolean\n}\n\n/**\n * Proxies tab focus within a container to a reference element\n * when the container is rendered in a portal\n */\n\nfunction proxyTabFocusImpl(container: MaybeElement, options: ProxyTabFocusOptions = {}) {\n  const { triggerElement, onFocus } = options\n\n  const doc = container?.ownerDocument || document\n  const body = doc.body\n\n  function onKeyDown(event: KeyboardEvent) {\n    if (event.key !== \"Tab\") return\n\n    let elementToFocus: MaybeElement | undefined = null\n\n    // get all tabbable elements within the container\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true)\n\n    const noTabbableElements = !firstTabbable && !lastTabbable\n\n    // if we're focused on the first tabbable element and the user tabs backwards\n    // we want to focus the reference element\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      // if we're focused on the reference element and the user tabs forwards\n      // we want to focus the first tabbable element\n      elementToFocus = firstTabbable\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      // if we're focused on the last tabbable element and the user tabs forwards\n      // we want to focus the next tabbable element after the reference element\n      elementToFocus = getNextTabbable(body, triggerElement)\n    }\n\n    if (!elementToFocus) return\n\n    event.preventDefault()\n\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus)\n    } else {\n      elementToFocus.focus()\n    }\n  }\n\n  // listen for the tab key in the capture phase\n  doc?.addEventListener(\"keydown\", onKeyDown, true)\n\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true)\n  }\n}\n\nexport function proxyTabFocus(container: NodeOrFn, options: ProxyTabFocusOptions<NodeOrFn>) {\n  const { defer, triggerElement, ...restOptions } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector) ?? null\n}\n", "import { getDocument } from \"./env\"\n\nexport interface ScopeContext {\n  getRootNode?(): Document | ShadowRoot | Node\n}\n\nexport function createScope<T>(methods: T) {\n  const dom = {\n    getRootNode: (ctx: ScopeContext) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: ScopeContext) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx: ScopeContext) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: ScopeContext) => dom.getRootNode(ctx).activeElement,\n    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => elem === dom.getActiveElement(ctx),\n    getById: <T extends Element = HTMLElement>(ctx: ScopeContext, id: string) =>\n      dom.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      const valueAsString = value.toString()\n      if (elem.value === valueAsString) return\n      elem.value = value.toString()\n    },\n  }\n\n  return { ...dom, ...methods }\n}\n", "import { isOverflowElement } from \"./is-overflow-element\"\n\nexport interface ScrollOptions extends ScrollIntoViewOptions {\n  rootEl: HTMLElement | null\n}\n\nfunction isScrollable(el: HTMLElement): boolean {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth\n}\n\nexport function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void {\n  const { rootEl, ...scrollOptions } = options || {}\n\n  if (!el || !rootEl) {\n    return\n  }\n\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return\n  }\n\n  el.scrollIntoView(scrollOptions)\n}\n", "const cleanups = new WeakMap<Element, Map<string, () => void>>()\n\nexport function set(element: Element, key: string, setup: () => () => void) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, new Map())\n  }\n\n  const elementCleanups = cleanups.get(element)!\n  const prevCleanup = elementCleanups.get(key)\n\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup())\n    return () => {\n      elementCleanups.get(key)?.()\n      elementCleanups.delete(key)\n    }\n  }\n\n  const cleanup = setup()\n\n  const nextCleanup = () => {\n    cleanup()\n    prevCleanup()\n    elementCleanups.delete(key)\n  }\n\n  elementCleanups.set(key, nextCleanup)\n\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup\n    if (!isCurrent) return\n    cleanup()\n    elementCleanups.set(key, prevCleanup)\n  }\n}\n\nexport function setAttribute(element: Element, attr: string, value: string) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr)\n    element.setAttribute(attr, value)\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr)\n      } else {\n        element.setAttribute(attr, previousValue)\n      }\n    }\n  }\n\n  return set(element, attr, setup)\n}\n\nexport function setProperty<T extends Element, K extends keyof T & string>(element: T, property: K, value: T[K]) {\n  const setup = () => {\n    const exists = property in element\n    const previousValue = element[property]\n    element[property] = value\n    return () => {\n      if (!exists) {\n        delete element[property]\n      } else {\n        element[property] = previousValue\n      }\n    }\n  }\n\n  return set(element, property, setup)\n}\n\nexport function setStyle(element: HTMLElement | null | undefined, style: Partial<CSSStyleDeclaration>) {\n  if (!element) return () => {}\n\n  const setup = () => {\n    const prevStyle = element.style.cssText\n    Object.assign(element.style, style)\n    return () => {\n      element.style.cssText = prevStyle\n    }\n  }\n\n  return set(element, \"style\", setup)\n}\n", "export const visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\",\n} as const\n", "import { isHTMLElement } from \"./is\"\n\ntype ElementGetter = () => Element | null\n\nconst fps = 1000 / 60\n\nexport function waitForElement(query: ElementGetter, cb: (el: HTMLElement) => void) {\n  const el = query()\n\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el)\n    return () => void 0\n  } else {\n    const timerId = setInterval(() => {\n      const el = query()\n      if (isHTMLElement(el) && el.isConnected) {\n        cb(el)\n        clearInterval(timerId)\n      }\n    }, fps)\n\n    return () => clearInterval(timerId)\n  }\n}\n\nexport function waitForElements(queries: ElementGetter[], cb: (el: HTMLElement) => void) {\n  const cleanups: VoidFunction[] = []\n\n  queries?.forEach((query) => {\n    const clean = waitForElement(query, cb)\n    cleanups.push(clean)\n  })\n\n  return () => {\n    cleanups.forEach((fn) => fn())\n  }\n}\n", "import { isIos } from \"@zag-js/dom-query\"\n\nconst LOCK_CLASSNAME = \"data-zag-scroll-lock\"\n\nfunction assignStyle(el: HTMLElement | null | undefined, style: Partial<CSSStyleDeclaration>) {\n  if (!el) return\n  const previousStyle = el.style.cssText\n  Object.assign(el.style, style)\n  return () => {\n    el.style.cssText = previousStyle\n  }\n}\n\nfunction setCSSProperty(el: HTMLElement | null | undefined, property: string, value: string) {\n  if (!el) return\n  const previousValue = el.style.getPropertyValue(property)\n  el.style.setProperty(property, value)\n  return () => {\n    if (previousValue) {\n      el.style.setProperty(property, previousValue)\n    } else {\n      el.style.removeProperty(property)\n    }\n  }\n}\n\nfunction getPaddingProperty(documentElement: HTMLElement) {\n  // RTL <body> scrollbar\n  const documentLeft = documentElement.getBoundingClientRect().left\n  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft\n  return scrollbarX ? \"paddingLeft\" : \"paddingRight\"\n}\n\nexport function preventBodyScroll(_document?: Document) {\n  const doc = _document ?? document\n  const win = doc.defaultView ?? window\n\n  const { documentElement, body } = doc\n\n  const locked = body.hasAttribute(LOCK_CLASSNAME)\n  if (locked) return\n\n  body.setAttribute(LOCK_CLASSNAME, \"\")\n\n  const scrollbarWidth = win.innerWidth - documentElement.clientWidth\n  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, \"--scrollbar-width\", `${scrollbarWidth}px`)\n  const paddingProperty = getPaddingProperty(documentElement)\n\n  const setStyle = () =>\n    assignStyle(body, {\n      overflow: \"hidden\",\n      [paddingProperty]: `${scrollbarWidth}px`,\n    })\n\n  // Only iOS doesn't respect `overflow: hidden` on document.body\n  const setIOSStyle = () => {\n    const { scrollX, scrollY, visualViewport } = win\n\n    // iOS 12 does not support `visuaViewport`.\n    const offsetLeft = visualViewport?.offsetLeft ?? 0\n    const offsetTop = visualViewport?.offsetTop ?? 0\n\n    const restoreStyle = assignStyle(body, {\n      position: \"fixed\",\n      overflow: \"hidden\",\n      top: `${-(scrollY - Math.floor(offsetTop))}px`,\n      left: `${-(scrollX - Math.floor(offsetLeft))}px`,\n      right: \"0\",\n      [paddingProperty]: `${scrollbarWidth}px`,\n    })\n\n    return () => {\n      restoreStyle?.()\n      win.scrollTo({ left: scrollX, top: scrollY, behavior: \"instant\" })\n    }\n  }\n\n  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()]\n\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n    body.removeAttribute(LOCK_CLASSNAME)\n  }\n}\n", "// Clamp a value between a minimum and maximum value\r\nexport function clamp(min, input, max) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n// Truncate a floating-point number to a specified number of decimal places\r\nexport function truncate(value, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\r\nexport function lerp(x, y, t) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nexport function damp(x, y, lambda, dt) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\r\n}\r\n\r\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n// https://anguscroll.com/just/just-modulo\r\nexport function modulo(n, d) {\r\n  return ((n % d) + d) % d\r\n}\r\n", "import { clamp, damp } from './maths'\r\n\r\n// Animate class to handle value animations with lerping or easing\r\nexport class Animate {\r\n  // Advance the animation by the given delta time\r\n  advance(deltaTime) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  // Stop the animation\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  // Set up the animation from a starting value to an ending value\r\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\r\n  fromTo(from, to, { lerp, duration, easing, onStart, onUpdate }) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n", "import { debounce } from './debounce'\r\n\r\nexport class Dimensions {\r\n  constructor({\r\n    wrapper,\r\n    content,\r\n    autoResize = true,\r\n    debounce: debounceValue = 250,\r\n  } = {}) {\r\n    this.wrapper = wrapper\r\n    this.content = content\r\n\r\n    if (autoResize) {\r\n      this.debouncedResize = debounce(this.resize, debounceValue)\r\n\r\n      if (this.wrapper === window) {\r\n        window.addEventListener('resize', this.debouncedResize, false)\r\n      } else {\r\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n    window.removeEventListener('resize', this.debouncedResize, false)\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.scrollHeight = this.content.scrollHeight\r\n      this.scrollWidth = this.content.scrollWidth\r\n    } else {\r\n      this.scrollHeight = this.wrapper.scrollHeight\r\n      this.scrollWidth = this.wrapper.scrollWidth\r\n    }\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n", "export function debounce(callback, delay) {\r\n  let timer\r\n  return function () {\r\n    let args = arguments\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(function () {\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n", "export class Emitter {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  emit(event, ...args) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i](...args)\r\n    }\r\n  }\r\n\r\n  on(event, cb) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  off(event, callback) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n", "import { Emitter } from './emitter'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\n\r\nexport class VirtualScroll {\r\n  constructor(element, { wheelMultiplier = 1, touchMultiplier = 1 }) {\r\n    this.element = element\r\n    this.wheelMultiplier = wheelMultiplier\r\n    this.touchMultiplier = touchMultiplier\r\n\r\n    this.touchStart = {\r\n      x: null,\r\n      y: null,\r\n    }\r\n\r\n    this.emitter = new Emitter()\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\r\n    this.element.addEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Add an event listener for the given event and callback\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  // Remove all event listeners and clean up\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchstart' event\r\n  onTouchStart = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchmove' event\r\n  onTouchMove = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'wheel' event\r\n  onWheel = (event) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.windowWidth : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.windowHeight : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.wheelMultiplier\r\n    deltaY *= this.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.windowWidth = window.innerWidth\r\n    this.windowHeight = window.innerHeight\r\n  }\r\n}\r\n", "import { version } from '../../../package.json'\r\nimport { Animate } from './animate'\r\nimport { Dimensions } from './dimensions'\r\nimport { Emitter } from './emitter'\r\nimport { clamp, modulo } from './maths'\r\nimport { VirtualScroll } from './virtual-scroll'\r\n\r\n// Technical explanation\r\n// - listen to 'wheel' events\r\n// - prevent 'wheel' event to prevent scroll\r\n// - normalize wheel delta\r\n// - add delta to targetScroll\r\n// - animate scroll to targetScroll (smooth context)\r\n// - if animation is not running, listen to 'scroll' events (native context)\r\n\r\ntype EasingFunction = (t: number) => number\r\ntype Orientation = 'vertical' | 'horizontal'\r\ntype GestureOrientation = 'vertical' | 'horizontal' | 'both'\r\ntype Scrolling = boolean | 'native' | 'smooth'\r\n\r\nexport type LenisOptions = Partial<{\r\n  wrapper: Window | HTMLElement\r\n  content: HTMLElement\r\n  wheelEventsTarget: Window | HTMLElement\r\n  eventsTarget: Window | HTMLElement\r\n  smoothWheel: boolean\r\n  syncTouch: boolean\r\n  syncTouchLerp: number\r\n  touchInertiaMultiplier: number\r\n  duration: number\r\n  easing: EasingFunction\r\n  lerp: number\r\n  infinite: boolean\r\n  orientation: Orientation\r\n  gestureOrientation: GestureOrientation\r\n  touchMultiplier: number\r\n  wheelMultiplier: number\r\n  autoResize: boolean\r\n  prevent: boolean | ((node: Element) => boolean)\r\n  __experimental__naiveDimensions: boolean\r\n}>\r\n\r\nexport default class Lenis {\r\n  // __isSmooth: boolean = false // true if scroll should be animated\r\n  __isScrolling: Scrolling = false // true when scroll is animating\r\n  __isStopped: boolean = false // true if user should not be able to scroll - enable/disable programmatically\r\n  __isLocked: boolean = false // same as isStopped but enabled/disabled when scroll reaches target\r\n\r\n  time: number\r\n  userData: object\r\n  lastVelocity: number\r\n  velocity: number\r\n  direction: 1 | -1 | 0 = 0\r\n  options: LenisOptions\r\n  targetScroll: number\r\n  animatedScroll: number\r\n  // animate: Animate\r\n  // emitter: Emitter\r\n  // dimensions: Dimensions\r\n  // virtualScroll: VirtualScroll\r\n\r\n  constructor({\r\n    wrapper = window,\r\n    content = document.documentElement,\r\n    wheelEventsTarget = wrapper, // deprecated\r\n    eventsTarget = wheelEventsTarget,\r\n    smoothWheel = true,\r\n    syncTouch = false,\r\n    syncTouchLerp = 0.075,\r\n    touchInertiaMultiplier = 35,\r\n    duration, // in seconds\r\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n    lerp = 0.1,\r\n    infinite = false,\r\n    orientation = 'vertical', // vertical, horizontal\r\n    gestureOrientation = 'vertical', // vertical, horizontal, both\r\n    touchMultiplier = 1,\r\n    wheelMultiplier = 1,\r\n    autoResize = true,\r\n    prevent = false,\r\n    __experimental__naiveDimensions = false,\r\n  }: LenisOptions = {}) {\r\n    // @ts-expect-error\r\n    window.lenisVersion = version\r\n\r\n    // if wrapper is html or body, fallback to window\r\n    if (\r\n      !wrapper ||\r\n      wrapper === document.documentElement ||\r\n      wrapper === document.body\r\n    ) {\r\n      wrapper = window\r\n    }\r\n\r\n    this.options = {\r\n      wrapper,\r\n      content,\r\n      wheelEventsTarget,\r\n      eventsTarget,\r\n      smoothWheel,\r\n      syncTouch,\r\n      syncTouchLerp,\r\n      touchInertiaMultiplier,\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      infinite,\r\n      gestureOrientation,\r\n      orientation,\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      autoResize,\r\n      prevent,\r\n      __experimental__naiveDimensions,\r\n    }\r\n\r\n    this.animate = new Animate()\r\n    this.emitter = new Emitter()\r\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\r\n    // this.toggleClassName('lenis', true)\r\n    this.updateClassName()\r\n\r\n    this.userData = {}\r\n    this.time = 0\r\n    this.velocity = this.lastVelocity = 0\r\n    this.isLocked = false\r\n    this.isStopped = false\r\n    // this.hasScrolled = false\r\n    // this.isSmooth = syncTouch || smoothWheel\r\n    // this.isSmooth = false\r\n    this.isScrolling = false\r\n    this.targetScroll = this.animatedScroll = this.actualScroll\r\n\r\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\r\n\r\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n    })\r\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\r\n  }\r\n\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.options.wrapper.removeEventListener(\r\n      'scroll',\r\n      this.onNativeScroll,\r\n      false\r\n    )\r\n\r\n    this.virtualScroll.destroy()\r\n    this.dimensions.destroy()\r\n\r\n    this.cleanUpClassName()\r\n\r\n    // this.rootElement.className = ''\r\n\r\n    // this.toggleClassName('lenis', false)\r\n    // this.toggleClassName('lenis-smooth', false)\r\n    // this.toggleClassName('lenis-scrolling', false)\r\n    // this.toggleClassName('lenis-stopped', false)\r\n    // this.toggleClassName('lenis-locked', false)\r\n  }\r\n\r\n  on(event: string, callback: Function) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  off(event: string, callback: Function) {\r\n    return this.emitter.off(event, callback)\r\n  }\r\n\r\n  private setScroll(scroll: number) {\r\n    // apply scroll value immediately\r\n    if (this.isHorizontal) {\r\n      this.rootElement.scrollLeft = scroll\r\n    } else {\r\n      this.rootElement.scrollTop = scroll\r\n    }\r\n  }\r\n\r\n  private onVirtualScroll = ({\r\n    deltaX,\r\n    deltaY,\r\n    event,\r\n  }: {\r\n    deltaX: number\r\n    deltaY: number\r\n    event: WheelEvent | TouchEvent\r\n  }) => {\r\n    // keep zoom feature\r\n    if (event.ctrlKey) return\r\n\r\n    const isTouch = event.type.includes('touch')\r\n    const isWheel = event.type.includes('wheel')\r\n\r\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\r\n    // if (event.type === 'touchend') {\r\n    //   console.log('touchend', this.scroll)\r\n    //   // this.lastVelocity = this.velocity\r\n    //   // this.velocity = 0\r\n    //   // this.isScrolling = false\r\n    //   this.emit({ type: 'touchend' })\r\n    //   // alert('touchend')\r\n    //   return\r\n    // }\r\n\r\n    const isTapToStop =\r\n      this.options.syncTouch &&\r\n      isTouch &&\r\n      event.type === 'touchstart' &&\r\n      !this.isStopped &&\r\n      !this.isLocked\r\n\r\n    if (isTapToStop) {\r\n      this.reset()\r\n      return\r\n    }\r\n\r\n    const isClick = deltaX === 0 && deltaY === 0 // click event\r\n\r\n    // const isPullToRefresh =\r\n    //   this.options.gestureOrientation === 'vertical' &&\r\n    //   this.scroll === 0 &&\r\n    //   !this.options.infinite &&\r\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\r\n\r\n    const isUnknownGesture =\r\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\r\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\r\n\r\n    if (isClick || isUnknownGesture) {\r\n      // console.log('prevent')\r\n      return\r\n    }\r\n\r\n    // catch if scrolling on nested scroll elements\r\n    let composedPath = event.composedPath()\r\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\r\n\r\n    const prevent = this.options.prevent\r\n\r\n    if (\r\n      !!composedPath.find(\r\n        (node) =>\r\n          node instanceof Element &&\r\n          ((typeof prevent === 'function' ? prevent?.(node) : prevent) ||\r\n            node.hasAttribute?.('data-lenis-prevent') ||\r\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\r\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\r\n            (node.classList?.contains('lenis') &&\r\n              !node.classList?.contains('lenis-stopped'))) // nested lenis instance\r\n      )\r\n    )\r\n      return\r\n\r\n    if (this.isStopped || this.isLocked) {\r\n      event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\r\n      return\r\n    }\r\n\r\n    const isSmooth =\r\n      (this.options.syncTouch && isTouch) ||\r\n      (this.options.smoothWheel && isWheel)\r\n\r\n    if (!isSmooth) {\r\n      this.isScrolling = 'native'\r\n      this.animate.stop()\r\n      return\r\n    }\r\n\r\n    event.preventDefault()\r\n\r\n    let delta = deltaY\r\n    if (this.options.gestureOrientation === 'both') {\r\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\r\n    } else if (this.options.gestureOrientation === 'horizontal') {\r\n      delta = deltaX\r\n    }\r\n\r\n    const syncTouch = isTouch && this.options.syncTouch\r\n    const isTouchEnd = isTouch && event.type === 'touchend'\r\n\r\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5\r\n\r\n    if (hasTouchInertia) {\r\n      delta = this.velocity * this.options.touchInertiaMultiplier\r\n    }\r\n\r\n    this.scrollTo(this.targetScroll + delta, {\r\n      programmatic: false,\r\n      ...(syncTouch\r\n        ? {\r\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\r\n          }\r\n        : {\r\n            lerp: this.options.lerp,\r\n            duration: this.options.duration,\r\n            easing: this.options.easing,\r\n          }),\r\n    })\r\n  }\r\n\r\n  resize() {\r\n    this.dimensions.resize()\r\n  }\r\n\r\n  private emit() {\r\n    this.emitter.emit('scroll', this)\r\n  }\r\n\r\n  private onNativeScroll = () => {\r\n    clearTimeout(this.__resetVelocityTimeout)\r\n    delete this.__resetVelocityTimeout\r\n\r\n    if (this.__preventNextNativeScrollEvent) {\r\n      delete this.__preventNextNativeScrollEvent\r\n      return\r\n    }\r\n\r\n    if (this.isScrolling === false || this.isScrolling === 'native') {\r\n      const lastScroll = this.animatedScroll\r\n      this.animatedScroll = this.targetScroll = this.actualScroll\r\n      this.lastVelocity = this.velocity\r\n      this.velocity = this.animatedScroll - lastScroll\r\n      this.direction = Math.sign(\r\n        this.animatedScroll - lastScroll\r\n      ) as Lenis['direction']\r\n      // this.isSmooth = false\r\n      this.isScrolling = 'native'\r\n      this.emit()\r\n\r\n      if (this.velocity !== 0) {\r\n        this.__resetVelocityTimeout = setTimeout(() => {\r\n          this.lastVelocity = this.velocity\r\n          this.velocity = 0\r\n          this.isScrolling = false\r\n          this.emit()\r\n        }, 400)\r\n      }\r\n\r\n      // this.hasScrolled = true\r\n      // }, 50)\r\n    }\r\n  }\r\n\r\n  private reset() {\r\n    this.isLocked = false\r\n    this.isScrolling = false\r\n    this.animatedScroll = this.targetScroll = this.actualScroll\r\n    this.lastVelocity = this.velocity = 0\r\n    this.animate.stop()\r\n  }\r\n\r\n  start() {\r\n    if (!this.isStopped) return\r\n    this.isStopped = false\r\n\r\n    this.reset()\r\n  }\r\n\r\n  stop() {\r\n    if (this.isStopped) return\r\n    this.isStopped = true\r\n    this.animate.stop()\r\n\r\n    this.reset()\r\n  }\r\n\r\n  raf(time: number) {\r\n    const deltaTime = time - (this.time || time)\r\n    this.time = time\r\n\r\n    this.animate.advance(deltaTime * 0.001)\r\n  }\r\n\r\n  scrollTo(\r\n    target: number | string | HTMLElement,\r\n    {\r\n      offset = 0,\r\n      immediate = false,\r\n      lock = false,\r\n      duration = this.options.duration,\r\n      easing = this.options.easing,\r\n      lerp = this.options.lerp,\r\n      onStart,\r\n      onComplete,\r\n      force = false, // scroll even if stopped\r\n      programmatic = true, // called from outside of the class\r\n      userData = {},\r\n    }: {\r\n      offset?: number\r\n      immediate?: boolean\r\n      lock?: boolean\r\n      duration?: number\r\n      easing?: EasingFunction\r\n      lerp?: number\r\n      onStart?: (lenis: Lenis) => void\r\n      onComplete?: (lenis: Lenis) => void\r\n      force?: boolean\r\n      programmatic?: boolean\r\n      userData?: object\r\n    } = {}\r\n  ) {\r\n    if ((this.isStopped || this.isLocked) && !force) return\r\n\r\n    // keywords\r\n    if (\r\n      typeof target === 'string' &&\r\n      ['top', 'left', 'start'].includes(target)\r\n    ) {\r\n      target = 0\r\n    } else if (\r\n      typeof target === 'string' &&\r\n      ['bottom', 'right', 'end'].includes(target)\r\n    ) {\r\n      target = this.limit\r\n    } else {\r\n      let node\r\n\r\n      if (typeof target === 'string') {\r\n        // CSS selector\r\n        node = document.querySelector(target)\r\n      } else if (target instanceof HTMLElement && target?.nodeType) {\r\n        // Node element\r\n        node = target\r\n      }\r\n\r\n      if (node) {\r\n        if (this.options.wrapper !== window) {\r\n          // nested scroll offset correction\r\n          const wrapperRect = this.rootElement.getBoundingClientRect()\r\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\r\n        }\r\n\r\n        const rect = node.getBoundingClientRect()\r\n\r\n        target =\r\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\r\n      }\r\n    }\r\n\r\n    if (typeof target !== 'number') return\r\n\r\n    target += offset\r\n    target = Math.round(target)\r\n\r\n    if (this.options.infinite) {\r\n      if (programmatic) {\r\n        this.targetScroll = this.animatedScroll = this.scroll\r\n      }\r\n    } else {\r\n      target = clamp(0, target, this.limit)\r\n    }\r\n\r\n    if (target === this.targetScroll) return\r\n\r\n    this.userData = userData\r\n\r\n    if (immediate) {\r\n      this.animatedScroll = this.targetScroll = target\r\n      this.setScroll(this.scroll)\r\n      this.reset()\r\n      this.preventNextNativeScrollEvent()\r\n      this.emit()\r\n      onComplete?.(this)\r\n      this.userData = {}\r\n      return\r\n    }\r\n\r\n    if (!programmatic) {\r\n      this.targetScroll = target\r\n    }\r\n\r\n    this.animate.fromTo(this.animatedScroll, target, {\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      onStart: () => {\r\n        // started\r\n        if (lock) this.isLocked = true\r\n        this.isScrolling = 'smooth'\r\n        onStart?.(this)\r\n      },\r\n      onUpdate: (value: number, completed: boolean) => {\r\n        this.isScrolling = 'smooth'\r\n\r\n        // updated\r\n        this.lastVelocity = this.velocity\r\n        this.velocity = value - this.animatedScroll\r\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\r\n\r\n        this.animatedScroll = value\r\n        this.setScroll(this.scroll)\r\n\r\n        if (programmatic) {\r\n          // wheel during programmatic should stop it\r\n          this.targetScroll = value\r\n        }\r\n\r\n        if (!completed) this.emit()\r\n\r\n        if (completed) {\r\n          this.reset()\r\n          this.emit()\r\n          onComplete?.(this)\r\n          this.userData = {}\r\n\r\n          // avoid emitting event twice\r\n          this.preventNextNativeScrollEvent()\r\n        }\r\n      },\r\n    })\r\n  }\r\n\r\n  private preventNextNativeScrollEvent() {\r\n    this.__preventNextNativeScrollEvent = true\r\n\r\n    requestAnimationFrame(() => {\r\n      delete this.__preventNextNativeScrollEvent\r\n    })\r\n  }\r\n\r\n  get rootElement() {\r\n    return (\r\n      this.options.wrapper === window\r\n        ? document.documentElement\r\n        : this.options.wrapper\r\n    ) as HTMLElement\r\n  }\r\n\r\n  get limit() {\r\n    if (this.options.__experimental__naiveDimensions) {\r\n      if (this.isHorizontal) {\r\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\r\n      } else {\r\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\r\n      }\r\n    } else {\r\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\r\n    }\r\n  }\r\n\r\n  get isHorizontal() {\r\n    return this.options.orientation === 'horizontal'\r\n  }\r\n\r\n  get actualScroll(): number {\r\n    // value browser takes into account\r\n    return this.isHorizontal\r\n      ? this.rootElement.scrollLeft\r\n      : this.rootElement.scrollTop\r\n  }\r\n\r\n  get scroll(): number {\r\n    return this.options.infinite\r\n      ? modulo(this.animatedScroll, this.limit)\r\n      : this.animatedScroll\r\n  }\r\n\r\n  get progress(): number {\r\n    // avoid progress to be NaN\r\n    return this.limit === 0 ? 1 : this.scroll / this.limit\r\n  }\r\n\r\n  // get isSmooth() {\r\n  //   return this.__isSmooth\r\n  // }\r\n\r\n  // private set isSmooth(value: boolean) {\r\n  //   if (this.__isSmooth !== value) {\r\n  //     this.__isSmooth = value\r\n  //     this.updateClassName()\r\n  //   }\r\n  // }\r\n\r\n  get isScrolling() {\r\n    return this.__isScrolling\r\n  }\r\n\r\n  private set isScrolling(value: Scrolling) {\r\n    if (this.__isScrolling !== value) {\r\n      this.__isScrolling = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isStopped() {\r\n    return this.__isStopped\r\n  }\r\n\r\n  private set isStopped(value: boolean) {\r\n    if (this.__isStopped !== value) {\r\n      this.__isStopped = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isLocked() {\r\n    return this.__isLocked\r\n  }\r\n\r\n  private set isLocked(value: boolean) {\r\n    if (this.__isLocked !== value) {\r\n      this.__isLocked = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isSmooth() {\r\n    return this.isScrolling === 'smooth'\r\n  }\r\n\r\n  get className() {\r\n    let className = 'lenis'\r\n    if (this.isStopped) className += ' lenis-stopped'\r\n    if (this.isLocked) className += ' lenis-locked'\r\n    if (this.isScrolling) className += ' lenis-scrolling'\r\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\r\n    // if (this.isScrolling === 'native') className += ' lenis-native'\r\n    // if (this.isSmooth) className += ' lenis-smooth'\r\n    return className\r\n  }\r\n\r\n  private updateClassName() {\r\n    this.cleanUpClassName()\r\n\r\n    this.rootElement.className =\r\n      `${this.rootElement.className} ${this.className}`.trim()\r\n  }\r\n\r\n  private cleanUpClassName() {\r\n    this.rootElement.className = this.rootElement.className\r\n      .replace(/lenis(-\\w+)?/g, '')\r\n      .trim()\r\n  }\r\n}\r\n", "export const selectors = {\r\n  revealType: '[data-reveal-type]',\r\n  revealParent: '[data-reveal-parent]',\r\n  toggleScroll: '[data-toggle-scroll]',\r\n  startScroll: '[data-start-scroll]',\r\n  stopScroll: '[data-stop-scroll]',\r\n  resetAnimation: '[data-reset-animation]',\r\n} as const;\r\n\r\nconst revealTypeValuesArray = ['chars', 'words', 'lines'] as const;\r\nexport const revealTypeValuesSet: Set<string> = new Set(revealTypeValuesArray);\r\nexport type RevealTypeValue = (typeof revealTypeValuesArray)[number];\r\n\r\nconst animationTypeValuesArray = [\r\n  'from-top',\r\n  'from-bottom',\r\n  'from-left-bottom',\r\n  'fade-from-bottom-left',\r\n] as const;\r\nexport const animationTypeValuesSet: Set<string> = new Set(animationTypeValuesArray);\r\nexport type AnimationTypeValue = (typeof animationTypeValuesArray)[number];\r\n\r\nexport type AnimationDataProps = {\r\n  revealType: RevealTypeValue;\r\n  animationType: AnimationTypeValue;\r\n  duration: number;\r\n  easing: string;\r\n  delay: number;\r\n  staggerDelay: number;\r\n  fromX: string | undefined;\r\n  fromY: string | undefined;\r\n  fromOpacity: string | undefined;\r\n  viewThreshold: number;\r\n  resetAnimation: string | undefined;\r\n};\r\n\r\nexport type AnimationDataKeys = keyof AnimationDataProps;\r\n\r\nconst gsapEaseArray = [\r\n  'power1',\r\n  'power1.in',\r\n  'power1.out',\r\n  'power1.inOut',\r\n  'power2',\r\n  'power2.in',\r\n  'power2.out',\r\n  'power2.inOut',\r\n  'power3',\r\n  'power3.in',\r\n  'power3.out',\r\n  'power3.inOut',\r\n  'power4',\r\n  'power4.in',\r\n  'power4.out',\r\n  'power4.inOut',\r\n  'back',\r\n  'back.in',\r\n  'back.out',\r\n  'back.inOut',\r\n  'bounce',\r\n  'bounce.in',\r\n  'bounce.out',\r\n  'bounce.inOut',\r\n  'circ',\r\n  'circ.in',\r\n  'circ.out',\r\n  'circ.inOut',\r\n  'elastic',\r\n  'elastic.in',\r\n  'elastic.out',\r\n  'elastic.inOut',\r\n  'expo',\r\n  'expo.in',\r\n  'expo.out',\r\n  'expo.inOut',\r\n  'sine',\r\n  'sine.in',\r\n  'sine.out',\r\n  'sine.inOut',\r\n] as const;\r\nexport const gsapEaseSet: Set<string> = new Set(gsapEaseArray);\r\nexport type GsapEaseType = (typeof gsapEaseArray)[number];\r\n", "import { preventBodyScroll } from '@zag-js/remove-scroll';\r\nimport Lenis from 'lenis';\r\n\r\nimport { selectors } from '@/utils/constants';\r\n\r\nconst init = () => {\r\n  if (document.body.dataset.noSmoothScroll !== undefined) return;\r\n\r\n  const activateLenis = () => {\r\n    return new Lenis({\r\n      lerp: 0.1,\r\n      wheelMultiplier: 0.7,\r\n      gestureOrientation: 'vertical',\r\n    });\r\n  };\r\n\r\n  let lenis = activateLenis();\r\n\r\n  function raf(time: number) {\r\n    lenis.raf(time);\r\n    requestAnimationFrame(raf);\r\n  }\r\n\r\n  requestAnimationFrame(raf);\r\n\r\n  const scrollTogglers = [...document.querySelectorAll(selectors.toggleScroll)] as HTMLElement[];\r\n  const scrollStartTriggers = [\r\n    ...document.querySelectorAll(selectors.startScroll),\r\n  ] as HTMLElement[];\r\n  const scrollStopTriggers = [...document.querySelectorAll(selectors.stopScroll)] as HTMLElement[];\r\n\r\n  let resetScroll: (() => void) | undefined = undefined;\r\n\r\n  for (let i = 0; i < scrollTogglers.length; i++) {\r\n    const scrollToggleElement = scrollTogglers[i];\r\n\r\n    scrollToggleElement.addEventListener('click', () => {\r\n      if (scrollToggleElement.classList.contains('stop-scroll')) {\r\n        resetScroll?.();\r\n        lenis = activateLenis();\r\n        scrollToggleElement.classList.remove('stop-scroll');\r\n        return;\r\n      }\r\n      resetScroll = preventBodyScroll();\r\n      lenis.destroy();\r\n      scrollToggleElement.classList.add('stop-scroll');\r\n    });\r\n  }\r\n\r\n  for (const startTrigger of scrollStartTriggers) {\r\n    startTrigger.addEventListener('click', () => {\r\n      lenis = activateLenis();\r\n      resetScroll?.();\r\n    });\r\n  }\r\n\r\n  for (const stopTrigger of scrollStopTriggers) {\r\n    stopTrigger.addEventListener('click', () => {\r\n      lenis.destroy();\r\n      resetScroll = preventBodyScroll();\r\n    });\r\n  }\r\n};\r\n\r\ninit();\r\n"],
  "mappings": "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",
  "names": ["clamp", "min", "input", "max", "Math", "Animate", "deltaTime", "this", "isRunning", "completed", "duration", "easing", "currentTime", "linearProgress", "easedProgress", "value", "from", "to", "lerp", "damp", "x", "y", "lambda", "dt", "t", "exp", "round", "stop", "onUpdate", "onStart", "Dimensions", "constructor", "wrapper", "content", "autoResize", "debounce", "debounceValue", "debouncedResize", "callback", "delay", "timer", "args", "arguments", "context", "clearTimeout", "setTimeout", "apply", "resize", "window", "addEventListener", "wrapperResizeObserver", "ResizeObserver", "observe", "contentResizeObserver", "destroy", "disconnect", "removeEventListener", "onWrapperResize", "onContentResize", "width", "innerWidth", "height", "innerHeight", "clientWidth", "clientHeight", "scrollHeight", "scrollWidth", "limit", "Emitter", "events", "event", "callbacks", "i", "length", "cb", "push", "filter", "LINE_HEIGHT", "VirtualScroll", "element", "wheelMultiplier", "touchMultiplier", "touchStart", "emitter", "onWindowResize", "onWheel", "passive", "onTouchStart", "onTouchMove", "onTouchEnd", "on", "clientX", "clientY", "targetTouches", "lastDelta", "emit", "deltaX", "deltaY", "deltaMode", "windowWidth", "windowHeight", "Lenis", "document", "documentElement", "wheelEventsTarget", "eventsTarget", "smoothWheel", "syncTouch", "syncTouchLerp", "touchInertiaMultiplier", "pow", "infinite", "orientation", "gestureOrientation", "prevent", "__experimental__naiveDimensions", "__isScrolling", "__isStopped", "__isLocked", "direction", "onVirtualScroll", "ctrlKey", "isTouch", "type", "includes", "isWheel", "isTouching", "options", "isStopped", "isLocked", "reset", "isClick", "isUnknownGesture", "composedPath", "slice", "indexOf", "rootElement", "find", "node", "Element", "_a", "hasAttribute", "call", "_b", "_c", "r", "classList", "_d", "contains", "_e", "preventDefault", "isScrolling", "animate", "delta", "abs", "hasTouchInertia", "velocity", "scrollTo", "targetScroll", "Object", "assign", "programmatic", "onNativeScroll", "__resetVelocityTimeout", "__preventNextNativeScrollEvent", "lastScroll", "animatedScroll", "actualScroll", "lastVelocity", "sign", "lenisVersion", "body", "dimensions", "updateClassName", "userData", "time", "virtualScroll", "cleanUpClassName", "off", "scroll", "isHorizontal", "scrollLeft", "scrollTop", "start", "advance", "target", "offset", "immediate", "lock", "onComplete", "force", "querySelector", "HTMLElement", "nodeType", "wrapperRect", "getBoundingClientRect", "left", "top", "rect", "setScroll", "preventNextNativeScrollEvent", "fromTo", "requestAnimationFrame", "modulo", "n", "d", "progress", "isSmooth", "className", "trim", "replace"]
}
