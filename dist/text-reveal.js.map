{
  "version": 3,
  "sources": ["../src/animations/text-reveal.ts"],
  "sourcesContent": ["import \"./text-reveal.css\";\r\n\r\nimport { wait } from \"@finsweet/ts-utils\";\r\nimport {\r\n  addWFCustomPageLoadFeature,\r\n  afterWebflowReady,\r\n  getGsap,\r\n  type GSAPTweenVars,\r\n  type GSAPType,\r\n} from \"@taj-wf/utils\";\r\n\r\nimport { selectors } from \"@/utils/constants\";\r\nimport { getAnimationValues } from \"@/utils/valueGetters\";\r\nimport { wrapHyphenatedWords } from \"@/utils/wrap-words\";\r\n\r\n/**\r\n * Text Reveal Animation Module\r\n *\r\n * This module creates animated text reveals using GSAP and SplitText.\r\n * It supports splitting text into characters, words, or lines and animating them\r\n * with different entrance animations when they enter the viewport.\r\n */\r\n\r\n// Type alias for GSAP timeline\r\ntype Timeline = ReturnType<GSAPType[\"timeline\"]>;\r\n\r\n/**\r\n * Initialize text reveal animations\r\n */\r\n\r\ntype TextRevealInstance = {\r\n  splitText: SplitText;\r\n  revealObserver: IntersectionObserver;\r\n  resetObserver: IntersectionObserver | undefined;\r\n};\r\n\r\ntype Nullish<T> = {\r\n  [K in keyof T]: T[K] | undefined;\r\n};\r\n\r\nlet textRevealInstances: Array<Nullish<TextRevealInstance>> = [];\r\n\r\n// Store lazy initialization observers\r\nlet lazyInitObservers: IntersectionObserver[] = [];\r\n\r\n// Store lazy initialization setup functions\r\nlet lazySetupInitializers: Array<() => void> = [];\r\n\r\nconst executeSplitSetupInitializers = () => {\r\n  for (const initializer of lazySetupInitializers) {\r\n    initializer();\r\n  }\r\n  lazySetupInitializers = [];\r\n};\r\n\r\nconst initTextReveal = () => {\r\n  // Add script-loaded class to body to enable CSS hiding\r\n  document.body.classList.add(\"text-reveal-script-loaded\");\r\n\r\n  // Barba Js Page Transitioner Instance\r\n  // @ts-expect-error barbe no types\r\n  const barbaInstance = window.BarbaInstance;\r\n\r\n  // Select all elements with a data-reveal-type attribute (chars, words, or lines)\r\n  const charRevealElements = document.querySelectorAll<HTMLElement>(selectors.revealType);\r\n\r\n  // Check if page has a loader by parsing loader duration from body attribute\r\n  const loaderDuration = Number.parseInt(document.body.dataset.loaderDuration ?? \"\");\r\n  const doesLoaderExist = !Number.isNaN(loaderDuration);\r\n\r\n  const [gsap, SplitText] = getGsap([\"SplitText\"]);\r\n\r\n  if (!gsap) {\r\n    console.error(\r\n      \"GSAP is not imported. GSAP Script must be loaded before text-reveal script. Get it from here: https://gsap.com/docs/v3/Installation/?tab=cdn&module=esm&require=false&plugins=SplitText\"\r\n    );\r\n    return;\r\n  }\r\n\r\n  if (!SplitText) {\r\n    console.error(\r\n      \"SplitText plugin script is not imported. SplitText Script must be loaded after GSAP script and before text-reveal script. Get it from here: https://gsap.com/docs/v3/Installation/?tab=cdn&module=esm&require=false&plugins=SplitText\"\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Create setup functions for lazy initialization observers for each text reveal element\r\n  for (let i = 0; i < charRevealElements.length; i++) {\r\n    // Target element to animate\r\n    const charRevealEl = charRevealElements[i]!;\r\n\r\n    // Use immediate parent for lazy initialization observer only\r\n    const lazyInitParentEl = charRevealEl.parentElement || charRevealEl;\r\n\r\n    // Create setup function that will be called when fonts/loaders are ready\r\n    const setupLazyObserver = () => {\r\n      // Flag to track if element has been initialized\r\n      let isInitialized = false;\r\n\r\n      /**\r\n       * Lazy initialization function - only called when element is near viewport\r\n       * This is where all the heavy computation happens\r\n       */\r\n      const lazyInitialize = () => {\r\n        if (isInitialized) return;\r\n        isInitialized = true;\r\n\r\n        // Find parent element for intersection observation (original logic)\r\n        // If data-reveal-parent exists, use it, otherwise use the element itself\r\n        const charRevealParentEl =\r\n          charRevealEl.closest<HTMLElement>(selectors.revealParent) || charRevealEl;\r\n\r\n        // Extract animation configuration from data attributes\r\n        // These values determine how the animation will behave\r\n        const {\r\n          animationType, // Type of animation (from-bottom, from-top, fade-from-bottom-left)\r\n          delay, // Delay before animation starts\r\n          duration, // Duration of animation\r\n          easing, // Easing function\r\n          revealType, // How text is split (chars, words, lines)\r\n          staggerDelay, // Delay between each animated element\r\n          fromX, // Starting X position for fade-from-bottom-left\r\n          fromY, // Starting Y position for fade-from-bottom-left\r\n          fromOpacity, // Starting opacity for fade-from-bottom-left\r\n          viewThreshold, // Viewport threshold to trigger animation\r\n        } = getAnimationValues(charRevealEl, undefined, charRevealParentEl);\r\n\r\n        /**\r\n         * Determine if split text should remain split after animation\r\n         * Checks data-keep-split on element or closest ancestor with that attribute\r\n         */\r\n        const getKeepSplit = () => {\r\n          const value =\r\n            charRevealEl.dataset.keepSplit ||\r\n            charRevealEl.closest<HTMLElement>(\"[data-keep-split]\")?.dataset.keepSplit;\r\n\r\n          if (value === \"true\") return true;\r\n          if (value === \"false\") return false;\r\n\r\n          return false;\r\n        };\r\n\r\n        /**\r\n         * Determine if animation should reset when element leaves viewport\r\n         * Checks data-reset-animation on element or closest ancestor with that attribute\r\n         */\r\n        const getResetAnimation = () => {\r\n          const value =\r\n            charRevealEl.dataset.resetAnimation ||\r\n            charRevealEl.closest<HTMLElement>(\"[data-reset-animation]\")?.dataset.resetAnimation;\r\n\r\n          if (value === \"true\") return true;\r\n          if (value === \"false\") return false;\r\n\r\n          return false;\r\n        };\r\n\r\n        const keepSplit = getKeepSplit();\r\n        const shouldAnimationReset = getResetAnimation();\r\n\r\n        // Animation properties for initial (hidden) and final (visible) states\r\n        const initialAnimationProps: GSAPTweenVars = {};\r\n        const finalAnimationProps: GSAPTweenVars = {};\r\n\r\n        // Configure animation properties based on animation type\r\n        if (animationType === \"from-bottom\") {\r\n          // Start below and animate up\r\n          initialAnimationProps.y = \"100%\";\r\n          finalAnimationProps.y = \"0%\";\r\n        } else if (animationType === \"from-top\") {\r\n          // Start above and animate down\r\n          initialAnimationProps.y = \"-100%\";\r\n          finalAnimationProps.y = \"0%\";\r\n        } else if (animationType === \"fade-from-bottom-left\") {\r\n          // Start from bottom-left with fade-in\r\n          initialAnimationProps.y = fromY || \"30%\";\r\n          initialAnimationProps.x = fromX || \"-50px\";\r\n          initialAnimationProps.opacity = fromOpacity || \"0.05\";\r\n\r\n          finalAnimationProps.y = \"0%\";\r\n          finalAnimationProps.x = \"0%\";\r\n          finalAnimationProps.opacity = \"1\";\r\n        }\r\n\r\n        // Add common animation properties\r\n        finalAnimationProps.delay = delay;\r\n        finalAnimationProps.duration = duration;\r\n        finalAnimationProps.ease = easing;\r\n        finalAnimationProps.stagger = staggerDelay;\r\n\r\n        // References to store created GSAP and SplitText instances\r\n        let ctx: ReturnType<GSAPType[\"context\"]> | undefined = undefined;\r\n        let tl: Timeline | undefined = undefined;\r\n        let splitter: globalThis.SplitText | undefined = undefined;\r\n        let splittedElements: Element[] | undefined = undefined;\r\n\r\n        /**\r\n         * Clean up GSAP timeline and context\r\n         */\r\n        const destroyTimeline = () => {\r\n          if (tl) {\r\n            tl.revert();\r\n            tl = undefined;\r\n          }\r\n          if (ctx) {\r\n            ctx.revert();\r\n            ctx = undefined;\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Create GSAP timeline for the animation\r\n         */\r\n        const initTimeline = () => {\r\n          ctx = gsap.context(() => {\r\n            // Create paused timeline - will be played when element enters viewport\r\n            tl = gsap.timeline({ paused: true });\r\n\r\n            // Set initial state (hidden)\r\n            tl.set(splittedElements!, initialAnimationProps).add(\"start\");\r\n\r\n            // Animate to final state (visible)\r\n            tl.to(splittedElements!, finalAnimationProps).add(\"end\");\r\n\r\n            // Set tiny progress to ensure initial state is applied\r\n            tl.progress(0.001);\r\n          });\r\n        };\r\n\r\n        /**\r\n         * Reset animation by destroying timeline and reverting split text\r\n         */\r\n        const resetSplitAnimation = () => {\r\n          destroyTimeline();\r\n          splitter?.revert();\r\n\r\n          // Fix layout shift for line animations\r\n          if (revealType === \"lines\" && !keepSplit) {\r\n            fixLineLayoutShiftAfterRevert();\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Fix layout shift for line animations by setting width before splitting\r\n         * This prevents content jumps when text is split into lines\r\n         * Uses getBoundingClientRect() to get precise decimal pixel values instead of\r\n         * offsetWidth which rounds down to integers\r\n         */\r\n        const fixLineLayoutShiftBeforeSplit = () => {\r\n          // Get exact width with decimal precision\r\n          const rect = charRevealEl.getBoundingClientRect();\r\n          const charRevealElWidth = rect.width + \"px\";\r\n\r\n          charRevealEl.style.minWidth = charRevealElWidth;\r\n        };\r\n\r\n        /**\r\n         * Remove fixed width after animation reverts\r\n         */\r\n        const fixLineLayoutShiftAfterRevert = () => {\r\n          charRevealEl.style.removeProperty(\"min-width\");\r\n        };\r\n\r\n        /**\r\n         * Create SplitText instance and configure it based on animation settings\r\n         */\r\n        const getSplitter = () => {\r\n          // Fix layout issues for line animations\r\n          if (revealType === \"lines\" && !keepSplit) {\r\n            wrapHyphenatedWords(charRevealEl);\r\n            fixLineLayoutShiftBeforeSplit();\r\n          }\r\n\r\n          const splitter = SplitText.create(charRevealEl, {\r\n            // For char animations, we need to split into words first, then chars\r\n            type: revealType === \"chars\" ? \"words, chars\" : revealType,\r\n            // To make lines responsive\r\n            autoSplit: revealType === \"lines\",\r\n            // Only use masks for from-top/from-bottom animations (not for fade animations)\r\n            mask:\r\n              animationType === \"fade-from-bottom-left\"\r\n                ? undefined\r\n                : revealType === \"chars\"\r\n                  ? \"words\"\r\n                  : revealType,\r\n            // To make sure chars wont break\r\n            smartWrap: revealType === \"chars\",\r\n            // CSS classes for split elements\r\n            charsClass: \"split-chars\",\r\n            wordsClass: \"split-words\",\r\n            linesClass: \"split-lines\",\r\n            // Initialize timeline when on split\r\n            onSplit: (split) => {\r\n              splittedElements = split[revealType];\r\n              initTimeline();\r\n            },\r\n          });\r\n\r\n          // Mark element as initialized so CSS can show it\r\n          // Works with CSS: [data-reveal-type]:not([data-initialized]) { visibility: hidden; }\r\n          charRevealEl.setAttribute(\"data-initialized\", \"\");\r\n          return splitter;\r\n        };\r\n\r\n        /**\r\n         * Handle element entering viewport - play animation\r\n         */\r\n        const onEnter = () => {\r\n          if (!tl) return;\r\n\r\n          // Play animation and clean up after if not keeping split text\r\n          tl.restart(true).then(() => {\r\n            if (keepSplit) return;\r\n            resetSplitAnimation();\r\n          });\r\n        };\r\n\r\n        /**\r\n         * Handle element leaving viewport - reset for animations that should restart\r\n         */\r\n        const onLeave = () => {\r\n          if (!shouldAnimationReset) return;\r\n\r\n          resetSplitAnimation();\r\n          // Recreate split text when element leaves viewport\r\n          splitter = getSplitter();\r\n        };\r\n\r\n        // Create initial split text setup\r\n        splitter = getSplitter();\r\n\r\n        // Create observer to detect when element enters viewport for animation\r\n        const revealObserver = new IntersectionObserver(\r\n          (entries) => {\r\n            for (const entry of entries) {\r\n              if (entry.isIntersecting) {\r\n                onEnter();\r\n                // If animation doesn't restart, we don't need to observe anymore\r\n                if (shouldAnimationReset) return;\r\n                revealObserver.unobserve(entry.target);\r\n              }\r\n            }\r\n          },\r\n          {\r\n            threshold: viewThreshold, // How much of element must be visible\r\n          }\r\n        );\r\n        revealObserver.observe(charRevealParentEl);\r\n\r\n        let resetObserver: IntersectionObserver | undefined = undefined;\r\n\r\n        // For restart animations, create observer to detect when element leaves viewport\r\n        if (shouldAnimationReset) {\r\n          resetObserver = new IntersectionObserver(\r\n            (entries) => {\r\n              for (const entry of entries) {\r\n                if (entry.isIntersecting) return;\r\n                onLeave();\r\n              }\r\n            },\r\n            {\r\n              threshold: 0,\r\n            }\r\n          );\r\n          resetObserver.observe(charRevealParentEl);\r\n        }\r\n\r\n        // Add to instances array after initialization\r\n        textRevealInstances.push({\r\n          splitText: splitter,\r\n          revealObserver,\r\n          resetObserver,\r\n        });\r\n      };\r\n\r\n      // Create lazy initialization observer with larger threshold to initialize before element enters viewport\r\n      const lazyInitObserver = new IntersectionObserver(\r\n        (entries) => {\r\n          for (const entry of entries) {\r\n            if (entry.isIntersecting) {\r\n              lazyInitialize();\r\n              // Unobserve after initialization since we only need to initialize once\r\n              lazyInitObserver.unobserve(entry.target);\r\n            }\r\n          }\r\n        },\r\n        {\r\n          // Initialize when element is within 200px of viewport\r\n          rootMargin: \"200px\",\r\n          threshold: 0,\r\n        }\r\n      );\r\n\r\n      // Observe the parent element for lazy initialization\r\n      lazyInitObserver.observe(lazyInitParentEl);\r\n      lazyInitObservers.push(lazyInitObserver);\r\n    };\r\n\r\n    // Push setup function to be executed when fonts/loaders are ready\r\n    lazySetupInitializers.push(setupLazyObserver);\r\n  }\r\n\r\n  // Initialize based on whether page has a loader\r\n  if (barbaInstance) {\r\n    barbaInstance.hooks.afterOnce(() => {\r\n      document.fonts.ready.then(() => {\r\n        executeSplitSetupInitializers();\r\n      });\r\n    });\r\n  } else if (doesLoaderExist) {\r\n    // If page has loader, wait for both loader and fonts before initializing\r\n    window.addEventListener(\"load\", async () => {\r\n      const fontsReadyPromise = document.fonts.ready;\r\n      const loaderPromise = wait(loaderDuration);\r\n      await Promise.all([fontsReadyPromise, loaderPromise]);\r\n      executeSplitSetupInitializers();\r\n    });\r\n  } else {\r\n    // Otherwise just wait for fonts to be ready\r\n    document.fonts.ready.then(() => {\r\n      executeSplitSetupInitializers();\r\n    });\r\n  }\r\n};\r\n\r\nconst destroyTextReveal = () => {\r\n  // Clean up existing text reveal instances\r\n  for (const instance of textRevealInstances) {\r\n    if (instance.splitText) {\r\n      instance.splitText.revert();\r\n      instance.splitText = undefined;\r\n    }\r\n    if (instance.revealObserver) {\r\n      instance.revealObserver.disconnect();\r\n      instance.revealObserver = undefined;\r\n    }\r\n    if (instance.resetObserver) {\r\n      instance.resetObserver.disconnect();\r\n      instance.resetObserver = undefined;\r\n    }\r\n  }\r\n  textRevealInstances = [];\r\n\r\n  // Clean up lazy initialization observers\r\n  for (const observer of lazyInitObservers) {\r\n    observer.disconnect();\r\n  }\r\n  lazyInitObservers = [];\r\n\r\n  // Clear any pending lazy setup initializers\r\n  lazySetupInitializers = [];\r\n};\r\n\r\ninitTextReveal();\r\n\r\naddWFCustomPageLoadFeature({\r\n  name: \"TEXT_REVEAL_ANIMATION\",\r\n  async: false,\r\n  init: initTextReveal,\r\n  destroy: destroyTextReveal,\r\n  reInit: () => {\r\n    destroyTextReveal();\r\n    initTextReveal();\r\n  },\r\n});\r\nafterWebflowReady(() => {});\r\n"],
  "mappings": "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",
  "names": ["splitter"]
}
