{
  "version": 3,
  "sources": ["../src/utils/constants.ts", "../src/utils/common.ts", "../src/utils/valueGetters.ts", "../src/utils/wrap-words.ts", "../src/animations/text-reveal.ts"],
  "sourcesContent": ["export const selectors = {\n  revealType: \"[data-reveal-type]\",\n  revealParent: \"[data-reveal-parent]\",\n  toggleScroll: \"[data-toggle-scroll]\",\n  startScroll: \"[data-start-scroll]\",\n  stopScroll: \"[data-stop-scroll]\",\n  resetAnimation: \"[data-reset-animation]\",\n  keepSplit: \"[data-reset-animation]\",\n} as const;\n\nconst revealTypeValuesArray = [\"chars\", \"words\", \"lines\"] as const;\nexport const revealTypeValuesSet: Set<string> = new Set(revealTypeValuesArray);\nexport type RevealTypeValue = (typeof revealTypeValuesArray)[number];\n\nconst animationTypeValuesArray = [\"from-top\", \"from-bottom\", \"fade-from-bottom-left\"] as const;\nexport const animationTypeValuesSet: Set<string> = new Set(animationTypeValuesArray);\nexport type AnimationTypeValue = (typeof animationTypeValuesArray)[number];\n\nexport type AnimationDataProps = {\n  revealType: RevealTypeValue;\n  animationType: AnimationTypeValue;\n  duration: number;\n  easing: string;\n  delay: number;\n  staggerDelay: number;\n  fromX: string | undefined;\n  fromY: string | undefined;\n  fromOpacity: string | undefined;\n  viewThreshold: number;\n  resetAnimation: string | undefined;\n};\n\nexport type AnimationDataKeys = keyof AnimationDataProps;\n\nconst gsapEaseArray = [\n  \"power1\",\n  \"power1.in\",\n  \"power1.out\",\n  \"power1.inOut\",\n  \"power2\",\n  \"power2.in\",\n  \"power2.out\",\n  \"power2.inOut\",\n  \"power3\",\n  \"power3.in\",\n  \"power3.out\",\n  \"power3.inOut\",\n  \"power4\",\n  \"power4.in\",\n  \"power4.out\",\n  \"power4.inOut\",\n  \"back\",\n  \"back.in\",\n  \"back.out\",\n  \"back.inOut\",\n  \"bounce\",\n  \"bounce.in\",\n  \"bounce.out\",\n  \"bounce.inOut\",\n  \"circ\",\n  \"circ.in\",\n  \"circ.out\",\n  \"circ.inOut\",\n  \"elastic\",\n  \"elastic.in\",\n  \"elastic.out\",\n  \"elastic.inOut\",\n  \"expo\",\n  \"expo.in\",\n  \"expo.out\",\n  \"expo.inOut\",\n  \"sine\",\n  \"sine.in\",\n  \"sine.out\",\n  \"sine.inOut\",\n] as const;\nexport const gsapEaseSet: Set<string> = new Set(gsapEaseArray);\nexport type GsapEaseType = (typeof gsapEaseArray)[number];\n", "class AssertionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AssertionError\";\n  }\n}\n\nexport const assert = <T>(value: T, message: string, condition?: (value: T) => boolean) => {\n  if (\n    value === null ||\n    value === undefined ||\n    Number.isNaN(value) ||\n    (condition && !condition(value))\n  ) {\n    throw new AssertionError(message);\n  }\n  return value;\n};\n\nexport const fallback = <T>(\n  value: T,\n  replacementValue: NonUndefined<T>,\n  condition?: (value: T) => boolean\n) => {\n  if (value !== undefined && condition && !condition(value)) {\n    return replacementValue;\n  }\n  if (value === undefined || Number.isNaN(value)) {\n    return replacementValue;\n  }\n\n  if (value === 0) return value;\n\n  return value;\n};\n\nexport const wait = (ms: number) => new Promise((res) => setTimeout(res, ms));\n", "import { fallback } from \"./common\";\r\nimport {\r\n  type AnimationDataKeys,\r\n  type AnimationDataProps,\r\n  type AnimationTypeValue,\r\n  animationTypeValuesSet,\r\n  gsapEaseSet,\r\n  type GsapEaseType,\r\n  type RevealTypeValue,\r\n  revealTypeValuesSet,\r\n} from \"./constants\";\r\n\r\nexport const getAnimationValues = (\r\n  element: HTMLElement,\r\n  defaultValues?: AnimationDataProps,\r\n  parentEl?: HTMLElement\r\n): AnimationDataProps => {\r\n  const {\r\n    animationType,\r\n    delay,\r\n    duration,\r\n    easing,\r\n    revealType,\r\n    staggerDelay,\r\n    fromX,\r\n    fromY,\r\n    fromOpacity,\r\n    viewThreshold,\r\n    resetAnimation,\r\n  } = element.dataset as Record<AnimationDataKeys, string | undefined>;\r\n  const parentViewThreshold = parentEl?.dataset.viewThreshold;\r\n\r\n  const selectedAnimationType = fallback(\r\n    animationType,\r\n    defaultValues?.animationType ?? \"from-bottom\",\r\n    (value) => value !== undefined && animationTypeValuesSet.has(value)\r\n  ) as AnimationTypeValue;\r\n\r\n  const selectedRevealType = fallback(\r\n    revealType,\r\n    defaultValues?.revealType ?? \"chars\",\r\n    (value) => value !== undefined && revealTypeValuesSet.has(value)\r\n  ) as RevealTypeValue;\r\n\r\n  const selectedEasing = fallback(\r\n    easing,\r\n    defaultValues?.easing ?? \"powe3.out\",\r\n    (value) => value !== undefined && gsapEaseSet.has(value)\r\n  ) as GsapEaseType;\r\n\r\n  const selectedDelay = fallback(Number.parseFloat(delay || \"\"), defaultValues?.delay ?? 0);\r\n  const selectedViewThreshold = fallback(\r\n    Number.parseFloat(viewThreshold || parentViewThreshold || \"\"),\r\n    defaultValues?.viewThreshold ?? 0.8\r\n  );\r\n  const selectedDuration = fallback(\r\n    Number.parseFloat(duration || \"\"),\r\n    defaultValues?.duration ?? 0.5\r\n  );\r\n  const selectedStaggerDelay = fallback(\r\n    Number.parseFloat(staggerDelay || \"\"),\r\n    defaultValues?.staggerDelay ?? 0.05\r\n  );\r\n\r\n  return {\r\n    animationType: selectedAnimationType,\r\n    revealType: selectedRevealType,\r\n    delay: selectedDelay,\r\n    duration: selectedDuration,\r\n    easing: selectedEasing,\r\n    staggerDelay: selectedStaggerDelay,\r\n    fromX,\r\n    fromY,\r\n    fromOpacity,\r\n    viewThreshold: selectedViewThreshold,\r\n    resetAnimation,\r\n  };\r\n};\r\n", "/**\n * Wraps words containing hyphens in span elements to prevent unwanted word breaks\n * @param element The HTML element to process\n */\nexport function wrapHyphenatedWords(element: HTMLElement): HTMLElement {\n  // Process all text nodes that contain hyphens\n  const textNodes = getTextNodesWithHyphens(element);\n\n  textNodes.forEach((textNode) => {\n    const text = textNode.nodeValue || \"\";\n\n    // Create a document fragment to hold the modified content\n    const fragment = document.createDocumentFragment();\n\n    // Split the text by spaces while preserving whitespace\n    const parts = text.split(/(\\s+)/);\n\n    for (const part of parts) {\n      // Check if the part contains a hyphen and is not just whitespace\n      if (part.includes(\"-\") && /\\S/.test(part)) {\n        const span = document.createElement(\"span\");\n        span.classList.add(\"split-word-nowrap\");\n        span.textContent = part;\n        fragment.appendChild(span);\n      } else {\n        // Keep non-hyphenated parts as they are\n        fragment.appendChild(document.createTextNode(part));\n      }\n    }\n\n    // Replace the original text node with our fragment\n    if (textNode.parentNode) {\n      textNode.parentNode.replaceChild(fragment, textNode);\n    }\n  });\n  return element;\n}\n\n/**\n * Gets all text nodes within an element that contain hyphens\n * @param element The element to search within\n * @returns Array of text nodes containing hyphens\n */\nfunction getTextNodesWithHyphens(element: Node): Text[] {\n  const result: Text[] = [];\n\n  // Use TreeWalker for efficient DOM traversal\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);\n\n  let node;\n  while ((node = walker.nextNode())) {\n    const textNode = node as Text;\n    // Only include text nodes that contain hyphens\n    if (textNode.nodeValue && textNode.nodeValue.includes(\"-\")) {\n      result.push(textNode);\n    }\n  }\n\n  return result;\n}\n", "import \"./text-reveal.css\";\r\n\r\nimport {\r\n  addWFCustomPageLoadFeature,\r\n  afterWebflowReady,\r\n  getGsap,\r\n  type GSAPTweenVars,\r\n  type GSAPType,\r\n} from \"@taj-wf/utils\";\r\n\r\nimport { selectors } from \"@/utils/constants\";\r\nimport { getAnimationValues } from \"@/utils/valueGetters\";\r\nimport { wrapHyphenatedWords } from \"@/utils/wrap-words\";\r\n\r\n/**\r\n * Text Reveal Animation Module\r\n *\r\n * This module creates animated text reveals using GSAP and SplitText.\r\n * It supports splitting text into characters, words, or lines and animating them\r\n * with different entrance animations when they enter the viewport.\r\n */\r\n\r\n// Type alias for GSAP timeline\r\ntype Timeline = ReturnType<GSAPType[\"timeline\"]>;\r\n\r\n/**\r\n * Initialize text reveal animations\r\n */\r\n\r\ntype TextRevealInstance = {\r\n  splitText: SplitText;\r\n  revealObserver: IntersectionObserver;\r\n  resetObserver: IntersectionObserver | undefined;\r\n};\r\n\r\ntype Nullish<T> = {\r\n  [K in keyof T]: T[K] | undefined;\r\n};\r\n\r\nlet textRevealInstances: Array<Nullish<TextRevealInstance>> = [];\r\n\r\n// Store lazy initialization observers\r\nlet lazyInitObservers: IntersectionObserver[] = [];\r\n\r\nconst initTextReveal = () => {\r\n  // Select all elements with a data-reveal-type attribute (chars, words, or lines)\r\n  const charRevealElements = document.querySelectorAll<HTMLElement>(selectors.revealType);\r\n\r\n  const [gsap, SplitText] = getGsap([\"SplitText\"]);\r\n\r\n  if (!gsap) {\r\n    console.error(\r\n      \"GSAP is not imported. GSAP Script must be loaded before text-reveal script. Get it from here: https://gsap.com/docs/v3/Installation/?tab=cdn&module=esm&require=false&plugins=SplitText\"\r\n    );\r\n    return;\r\n  }\r\n\r\n  if (!SplitText) {\r\n    console.error(\r\n      \"SplitText plugin script is not imported. SplitText Script must be loaded after GSAP script and before text-reveal script. Get it from here: https://gsap.com/docs/v3/Installation/?tab=cdn&module=esm&require=false&plugins=SplitText\"\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Create lazy initialization observer for each text reveal element\r\n  for (let i = 0; i < charRevealElements.length; i++) {\r\n    // Target element to animate\r\n    const charRevealEl = charRevealElements[i]!;\r\n\r\n    // Use immediate parent for lazy initialization observer only\r\n    const lazyInitParentEl = charRevealEl.parentElement || charRevealEl;\r\n\r\n    // Flag to track if element has been initialized\r\n    let isInitialized = false;\r\n\r\n    /**\r\n     * Lazy initialization function - only called when element is near viewport\r\n     * This is where all the heavy computation happens\r\n     */\r\n    const lazyInitialize = () => {\r\n      if (isInitialized) return;\r\n      isInitialized = true;\r\n\r\n      // Find parent element for intersection observation (original logic)\r\n      // If data-reveal-parent exists, use it, otherwise use the element itself\r\n      const charRevealParentEl =\r\n        charRevealEl.closest<HTMLElement>(selectors.revealParent) || charRevealEl;\r\n\r\n      // Extract animation configuration from data attributes\r\n      // These values determine how the animation will behave\r\n      const {\r\n        animationType, // Type of animation (from-bottom, from-top, fade-from-bottom-left)\r\n        delay, // Delay before animation starts\r\n        duration, // Duration of animation\r\n        easing, // Easing function\r\n        revealType, // How text is split (chars, words, lines)\r\n        staggerDelay, // Delay between each animated element\r\n        fromX, // Starting X position for fade-from-bottom-left\r\n        fromY, // Starting Y position for fade-from-bottom-left\r\n        fromOpacity, // Starting opacity for fade-from-bottom-left\r\n        viewThreshold, // Viewport threshold to trigger animation\r\n      } = getAnimationValues(charRevealEl, undefined, charRevealParentEl);\r\n\r\n      /**\r\n       * Determine if split text should remain split after animation\r\n       * Checks data-keep-split on element or closest ancestor with that attribute\r\n       */\r\n      const getKeepSplit = () => {\r\n        const value =\r\n          charRevealEl.dataset.keepSplit ||\r\n          charRevealEl.closest<HTMLElement>(\"[data-keep-split]\")?.dataset.keepSplit;\r\n\r\n        if (value === \"true\") return true;\r\n        if (value === \"false\") return false;\r\n\r\n        return false;\r\n      };\r\n\r\n      /**\r\n       * Determine if animation should reset when element leaves viewport\r\n       * Checks data-reset-animation on element or closest ancestor with that attribute\r\n       */\r\n      const getResetAnimation = () => {\r\n        const value =\r\n          charRevealEl.dataset.resetAnimation ||\r\n          charRevealEl.closest<HTMLElement>(\"[data-reset-animation]\")?.dataset.resetAnimation;\r\n\r\n        if (value === \"true\") return true;\r\n        if (value === \"false\") return false;\r\n\r\n        return false;\r\n      };\r\n\r\n      const keepSplit = getKeepSplit();\r\n      const shouldAnimationReset = getResetAnimation();\r\n\r\n      // Animation properties for initial (hidden) and final (visible) states\r\n      const initialAnimationProps: GSAPTweenVars = {};\r\n      const finalAnimationProps: GSAPTweenVars = {};\r\n\r\n      // Configure animation properties based on animation type\r\n      if (animationType === \"from-bottom\") {\r\n        // Start below and animate up\r\n        initialAnimationProps.y = \"100%\";\r\n        finalAnimationProps.y = \"0%\";\r\n      } else if (animationType === \"from-top\") {\r\n        // Start above and animate down\r\n        initialAnimationProps.y = \"-100%\";\r\n        finalAnimationProps.y = \"0%\";\r\n      } else if (animationType === \"fade-from-bottom-left\") {\r\n        // Start from bottom-left with fade-in\r\n        initialAnimationProps.y = fromY || \"30%\";\r\n        initialAnimationProps.x = fromX || \"-50px\";\r\n        initialAnimationProps.opacity = fromOpacity || \"0.05\";\r\n\r\n        finalAnimationProps.y = \"0%\";\r\n        finalAnimationProps.x = \"0%\";\r\n        finalAnimationProps.opacity = \"1\";\r\n      }\r\n\r\n      // Add common animation properties\r\n      finalAnimationProps.delay = delay;\r\n      finalAnimationProps.duration = duration;\r\n      finalAnimationProps.ease = easing;\r\n      finalAnimationProps.stagger = staggerDelay;\r\n\r\n      // References to store created GSAP and SplitText instances\r\n      let ctx: ReturnType<GSAPType[\"context\"]> | undefined = undefined;\r\n      let tl: Timeline | undefined = undefined;\r\n      let splitter: globalThis.SplitText | undefined = undefined;\r\n      let splittedElements: Element[] | undefined = undefined;\r\n\r\n      /**\r\n       * Clean up GSAP timeline and context\r\n       */\r\n      const destroyTimeline = () => {\r\n        if (tl) {\r\n          tl.revert();\r\n          tl = undefined;\r\n        }\r\n        if (ctx) {\r\n          ctx.revert();\r\n          ctx = undefined;\r\n        }\r\n      };\r\n\r\n      /**\r\n       * Create GSAP timeline for the animation\r\n       */\r\n      const initTimeline = () => {\r\n        ctx = gsap.context(() => {\r\n          // Create paused timeline - will be played when element enters viewport\r\n          tl = gsap.timeline({ paused: true });\r\n\r\n          // Set initial state (hidden)\r\n          tl.set(splittedElements!, initialAnimationProps).add(\"start\");\r\n\r\n          // Animate to final state (visible)\r\n          tl.to(splittedElements!, finalAnimationProps).add(\"end\");\r\n\r\n          // Set tiny progress to ensure initial state is applied\r\n          tl.progress(0.001);\r\n        });\r\n      };\r\n\r\n      /**\r\n       * Reset animation by destroying timeline and reverting split text\r\n       */\r\n      const resetSplitAnimation = () => {\r\n        destroyTimeline();\r\n        splitter?.revert();\r\n\r\n        // Fix layout shift for line animations\r\n        if (revealType === \"lines\" && !keepSplit) {\r\n          fixLineLayoutShiftAfterRevert();\r\n        }\r\n      };\r\n\r\n      /**\r\n       * Fix layout shift for line animations by setting width before splitting\r\n       * This prevents content jumps when text is split into lines\r\n       * Uses getBoundingClientRect() to get precise decimal pixel values instead of\r\n       * offsetWidth which rounds down to integers\r\n       */\r\n      const fixLineLayoutShiftBeforeSplit = () => {\r\n        // Get exact width with decimal precision\r\n        const rect = charRevealEl.getBoundingClientRect();\r\n        const charRevealElWidth = rect.width + \"px\";\r\n\r\n        charRevealEl.style.minWidth = charRevealElWidth;\r\n      };\r\n\r\n      /**\r\n       * Remove fixed width after animation reverts\r\n       */\r\n      const fixLineLayoutShiftAfterRevert = () => {\r\n        charRevealEl.style.removeProperty(\"min-width\");\r\n      };\r\n\r\n      /**\r\n       * Create SplitText instance and configure it based on animation settings\r\n       */\r\n      const getSplitter = () => {\r\n        // Fix layout issues for line animations\r\n        if (revealType === \"lines\" && !keepSplit) {\r\n          wrapHyphenatedWords(charRevealEl);\r\n          fixLineLayoutShiftBeforeSplit();\r\n        }\r\n\r\n        const splitter = SplitText.create(charRevealEl, {\r\n          // For char animations, we need to split into words first, then chars\r\n          type: revealType === \"chars\" ? \"words, chars\" : revealType,\r\n          // To make lines responsive\r\n          autoSplit: revealType === \"lines\",\r\n          // Only use masks for from-top/from-bottom animations (not for fade animations)\r\n          mask:\r\n            animationType === \"fade-from-bottom-left\"\r\n              ? undefined\r\n              : revealType === \"chars\"\r\n                ? \"words\"\r\n                : revealType,\r\n          // To make sure chars wont break\r\n          smartWrap: revealType === \"chars\",\r\n          // CSS classes for split elements\r\n          charsClass: \"split-chars\",\r\n          wordsClass: \"split-words\",\r\n          linesClass: \"split-lines\",\r\n          // Initialize timeline when on split\r\n          onSplit: (split) => {\r\n            splittedElements = split[revealType];\r\n            initTimeline();\r\n          },\r\n        });\r\n\r\n        // Mark element as initialized so CSS can show it\r\n        // Works with CSS: [data-reveal-type]:not([data-initialized]) { visibility: hidden; }\r\n        charRevealEl.setAttribute(\"data-initialized\", \"\");\r\n        return splitter;\r\n      };\r\n\r\n      /**\r\n       * Handle element entering viewport - play animation\r\n       */\r\n      const onEnter = () => {\r\n        if (!tl) return;\r\n\r\n        // Play animation and clean up after if not keeping split text\r\n        tl.restart(true).then(() => {\r\n          if (keepSplit) return;\r\n          resetSplitAnimation();\r\n        });\r\n      };\r\n\r\n      /**\r\n       * Handle element leaving viewport - reset for animations that should restart\r\n       */\r\n      const onLeave = () => {\r\n        if (!shouldAnimationReset) return;\r\n\r\n        resetSplitAnimation();\r\n        // Recreate split text when element leaves viewport\r\n        splitter = getSplitter();\r\n      };\r\n\r\n      // Create initial split text setup\r\n      splitter = getSplitter();\r\n\r\n      // Create observer to detect when element enters viewport for animation\r\n      const revealObserver = new IntersectionObserver(\r\n        (entries) => {\r\n          for (const entry of entries) {\r\n            if (entry.isIntersecting) {\r\n              onEnter();\r\n              // If animation doesn't restart, we don't need to observe anymore\r\n              if (shouldAnimationReset) return;\r\n              revealObserver.unobserve(entry.target);\r\n            }\r\n          }\r\n        },\r\n        {\r\n          threshold: viewThreshold, // How much of element must be visible\r\n        }\r\n      );\r\n      revealObserver.observe(charRevealParentEl);\r\n\r\n      let resetObserver: IntersectionObserver | undefined = undefined;\r\n\r\n      // For restart animations, create observer to detect when element leaves viewport\r\n      if (shouldAnimationReset) {\r\n        resetObserver = new IntersectionObserver(\r\n          (entries) => {\r\n            for (const entry of entries) {\r\n              if (entry.isIntersecting) return;\r\n              onLeave();\r\n            }\r\n          },\r\n          {\r\n            threshold: 0,\r\n          }\r\n        );\r\n        resetObserver.observe(charRevealParentEl);\r\n      }\r\n\r\n      // Add to instances array after initialization\r\n      textRevealInstances.push({\r\n        splitText: splitter,\r\n        revealObserver,\r\n        resetObserver,\r\n      });\r\n    };\r\n\r\n    // Create lazy initialization observer with larger threshold to initialize before element enters viewport\r\n    const lazyInitObserver = new IntersectionObserver(\r\n      (entries) => {\r\n        for (const entry of entries) {\r\n          if (entry.isIntersecting) {\r\n            lazyInitialize();\r\n            // Unobserve after initialization since we only need to initialize once\r\n            lazyInitObserver.unobserve(entry.target);\r\n          }\r\n        }\r\n      },\r\n      {\r\n        // Initialize when element is within 200px of viewport\r\n        rootMargin: \"200px\",\r\n        threshold: 0,\r\n      }\r\n    );\r\n\r\n    // Observe the parent element for lazy initialization\r\n    lazyInitObserver.observe(lazyInitParentEl);\r\n    lazyInitObservers.push(lazyInitObserver);\r\n  }\r\n\r\n  // No immediate initialization - everything is lazy-loaded when elements come near viewport\r\n  // The lazy initialization observers are already set up in the loop above\r\n};\r\n\r\nconst destroyTextReveal = () => {\r\n  // Clean up existing text reveal instances\r\n  for (const instance of textRevealInstances) {\r\n    if (instance.splitText) {\r\n      instance.splitText.revert();\r\n      instance.splitText = undefined;\r\n    }\r\n    if (instance.revealObserver) {\r\n      instance.revealObserver.disconnect();\r\n      instance.revealObserver = undefined;\r\n    }\r\n    if (instance.resetObserver) {\r\n      instance.resetObserver.disconnect();\r\n      instance.resetObserver = undefined;\r\n    }\r\n  }\r\n  textRevealInstances = [];\r\n\r\n  // Clean up lazy initialization observers\r\n  for (const observer of lazyInitObservers) {\r\n    observer.disconnect();\r\n  }\r\n  lazyInitObservers = [];\r\n};\r\n\r\nafterWebflowReady(() => {\r\n  initTextReveal();\r\n\r\n  addWFCustomPageLoadFeature({\r\n    name: \"TEXT_REVEAL_ANIMATION\",\r\n    async: false,\r\n    init: initTextReveal,\r\n    destroy: destroyTextReveal,\r\n    reInit: () => {\r\n      destroyTextReveal();\r\n      initTextReveal();\r\n    },\r\n  });\r\n});\r\n"],
  "mappings": "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",
  "names": ["splitter"]
}
