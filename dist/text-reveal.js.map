{
  "version": 3,
  "sources": ["../node_modules/.pnpm/@finsweet+ts-utils@0.40.0/node_modules/@finsweet/ts-utils/dist/helpers/wait.js", "../src/utils/constants.ts", "../src/utils/common.ts", "../src/utils/valueGetters.ts", "../src/utils/wrap-words.ts", "../src/animations/text-reveal.ts"],
  "sourcesContent": ["/**\n * @returns Awaitable promise for waiting X time.\n * @param time\n */\nexport const wait = (time) => new Promise((resolve) => setTimeout(resolve, time));\n", "export const selectors = {\n  revealType: \"[data-reveal-type]\",\n  revealParent: \"[data-reveal-parent]\",\n  toggleScroll: \"[data-toggle-scroll]\",\n  startScroll: \"[data-start-scroll]\",\n  stopScroll: \"[data-stop-scroll]\",\n  resetAnimation: \"[data-reset-animation]\",\n  keepSplit: \"[data-reset-animation]\",\n} as const;\n\nconst revealTypeValuesArray = [\"chars\", \"words\", \"lines\"] as const;\nexport const revealTypeValuesSet: Set<string> = new Set(revealTypeValuesArray);\nexport type RevealTypeValue = (typeof revealTypeValuesArray)[number];\n\nconst animationTypeValuesArray = [\"from-top\", \"from-bottom\", \"fade-from-bottom-left\"] as const;\nexport const animationTypeValuesSet: Set<string> = new Set(animationTypeValuesArray);\nexport type AnimationTypeValue = (typeof animationTypeValuesArray)[number];\n\nexport type AnimationDataProps = {\n  revealType: RevealTypeValue;\n  animationType: AnimationTypeValue;\n  duration: number;\n  easing: string;\n  delay: number;\n  staggerDelay: number;\n  fromX: string | undefined;\n  fromY: string | undefined;\n  fromOpacity: string | undefined;\n  viewThreshold: number;\n  resetAnimation: string | undefined;\n};\n\nexport type AnimationDataKeys = keyof AnimationDataProps;\n\nconst gsapEaseArray = [\n  \"power1\",\n  \"power1.in\",\n  \"power1.out\",\n  \"power1.inOut\",\n  \"power2\",\n  \"power2.in\",\n  \"power2.out\",\n  \"power2.inOut\",\n  \"power3\",\n  \"power3.in\",\n  \"power3.out\",\n  \"power3.inOut\",\n  \"power4\",\n  \"power4.in\",\n  \"power4.out\",\n  \"power4.inOut\",\n  \"back\",\n  \"back.in\",\n  \"back.out\",\n  \"back.inOut\",\n  \"bounce\",\n  \"bounce.in\",\n  \"bounce.out\",\n  \"bounce.inOut\",\n  \"circ\",\n  \"circ.in\",\n  \"circ.out\",\n  \"circ.inOut\",\n  \"elastic\",\n  \"elastic.in\",\n  \"elastic.out\",\n  \"elastic.inOut\",\n  \"expo\",\n  \"expo.in\",\n  \"expo.out\",\n  \"expo.inOut\",\n  \"sine\",\n  \"sine.in\",\n  \"sine.out\",\n  \"sine.inOut\",\n] as const;\nexport const gsapEaseSet: Set<string> = new Set(gsapEaseArray);\nexport type GsapEaseType = (typeof gsapEaseArray)[number];\n", "class AssertionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AssertionError\";\n  }\n}\n\nexport const assert = <T>(value: T, message: string, condition?: (value: T) => boolean) => {\n  if (\n    value === null ||\n    value === undefined ||\n    Number.isNaN(value) ||\n    (condition && !condition(value))\n  ) {\n    throw new AssertionError(message);\n  }\n  return value;\n};\n\nexport const fallback = <T>(\n  value: T,\n  replacementValue: NonUndefined<T>,\n  condition?: (value: T) => boolean\n) => {\n  if (value !== undefined && condition && !condition(value)) {\n    return replacementValue;\n  }\n  if (value === undefined || Number.isNaN(value)) {\n    return replacementValue;\n  }\n\n  if (value === 0) return value;\n\n  return value;\n};\n\nexport const wait = (ms: number) => new Promise((res) => setTimeout(res, ms));\n", "import { fallback } from \"./common\";\nimport {\n  type AnimationDataKeys,\n  type AnimationDataProps,\n  type AnimationTypeValue,\n  animationTypeValuesSet,\n  gsapEaseSet,\n  type GsapEaseType,\n  type RevealTypeValue,\n  revealTypeValuesSet,\n} from \"./constants\";\n\nexport const getAnimationValues = (\n  element: HTMLElement,\n  defaultValues?: AnimationDataProps,\n  parentEl?: HTMLElement\n): AnimationDataProps => {\n  const {\n    animationType,\n    delay,\n    duration,\n    easing,\n    revealType,\n    staggerDelay,\n    fromX,\n    fromY,\n    fromOpacity,\n    viewThreshold,\n    resetAnimation,\n  } = element.dataset as Record<AnimationDataKeys, string | undefined>;\n  const parentViewThreshold = parentEl?.dataset.viewThreshold;\n\n  const selectedAnimationType = fallback(\n    animationType,\n    defaultValues?.animationType ?? \"from-bottom\",\n    (value) => value !== undefined && animationTypeValuesSet.has(value)\n  ) as AnimationTypeValue;\n\n  const selectedRevealType = fallback(\n    revealType,\n    defaultValues?.revealType ?? \"chars\",\n    (value) => value !== undefined && revealTypeValuesSet.has(value)\n  ) as RevealTypeValue;\n\n  const selectedEasing = fallback(\n    easing,\n    defaultValues?.easing ?? \"powe3.out\",\n    (value) => value !== undefined && gsapEaseSet.has(value)\n  ) as GsapEaseType;\n\n  const selectedDelay = fallback(Number.parseFloat(delay || \"\"), defaultValues?.delay ?? 0);\n  const selectedViewThreshold = fallback(\n    Number.parseFloat(viewThreshold || parentViewThreshold || \"\"),\n    defaultValues?.viewThreshold ?? 0.8\n  );\n  const selectedDuration = fallback(\n    Number.parseFloat(duration || \"\"),\n    defaultValues?.duration ?? 0.5\n  );\n  const selectedStaggerDelay = fallback(\n    Number.parseFloat(staggerDelay || \"\"),\n    defaultValues?.staggerDelay ?? 0.05\n  );\n\n  return {\n    animationType: selectedAnimationType,\n    revealType: selectedRevealType,\n    delay: selectedDelay,\n    duration: selectedDuration,\n    easing: selectedEasing,\n    staggerDelay: selectedStaggerDelay,\n    fromX,\n    fromY,\n    fromOpacity,\n    viewThreshold: selectedViewThreshold,\n    resetAnimation,\n  };\n};\n", "/**\n * Wraps words containing hyphens in span elements to prevent unwanted word breaks\n * @param element The HTML element to process\n */\nexport function wrapHyphenatedWords(element: HTMLElement): HTMLElement {\n  // Process all text nodes that contain hyphens\n  const textNodes = getTextNodesWithHyphens(element);\n\n  textNodes.forEach((textNode) => {\n    const text = textNode.nodeValue || \"\";\n\n    // Create a document fragment to hold the modified content\n    const fragment = document.createDocumentFragment();\n\n    // Split the text by spaces while preserving whitespace\n    const parts = text.split(/(\\s+)/);\n\n    for (const part of parts) {\n      // Check if the part contains a hyphen and is not just whitespace\n      if (part.includes(\"-\") && /\\S/.test(part)) {\n        const span = document.createElement(\"span\");\n        span.classList.add(\"split-word-nowrap\");\n        span.textContent = part;\n        fragment.appendChild(span);\n      } else {\n        // Keep non-hyphenated parts as they are\n        fragment.appendChild(document.createTextNode(part));\n      }\n    }\n\n    // Replace the original text node with our fragment\n    if (textNode.parentNode) {\n      textNode.parentNode.replaceChild(fragment, textNode);\n    }\n  });\n  return element;\n}\n\n/**\n * Gets all text nodes within an element that contain hyphens\n * @param element The element to search within\n * @returns Array of text nodes containing hyphens\n */\nfunction getTextNodesWithHyphens(element: Node): Text[] {\n  const result: Text[] = [];\n\n  // Use TreeWalker for efficient DOM traversal\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);\n\n  let node;\n  while ((node = walker.nextNode())) {\n    const textNode = node as Text;\n    // Only include text nodes that contain hyphens\n    if (textNode.nodeValue && textNode.nodeValue.includes(\"-\")) {\n      result.push(textNode);\n    }\n  }\n\n  return result;\n}\n", "import \"./text-reveal.css\";\n\nimport { wait } from \"@finsweet/ts-utils\";\nimport {\n  addWFCustomPageLoadFeature,\n  afterWebflowReady,\n  getGsap,\n  type GSAPTweenVars,\n  type GSAPType,\n} from \"@taj-wf/utils\";\n\nimport { selectors } from \"@/utils/constants\";\nimport { getAnimationValues } from \"@/utils/valueGetters\";\nimport { wrapHyphenatedWords } from \"@/utils/wrap-words\";\n\n/**\n * Text Reveal Animation Module\n *\n * This module creates animated text reveals using GSAP and SplitText.\n * It supports splitting text into characters, words, or lines and animating them\n * with different entrance animations when they enter the viewport.\n */\n\n// Type alias for GSAP timeline\ntype Timeline = ReturnType<GSAPType[\"timeline\"]>;\n\n/**\n * Initialize text reveal animations\n */\n\ntype TextRevealInstance = {\n  splitText: SplitText;\n  revealObserver: IntersectionObserver;\n  resetObserver: IntersectionObserver | undefined;\n};\n\ntype Nullish<T> = {\n  [K in keyof T]: T[K] | undefined;\n};\n\nlet textRevealInstances: Array<Nullish<TextRevealInstance>> = [];\n\nlet splitSetupInitializers: Array<() => TextRevealInstance> = [];\n\nconst executeSplitSetupInitializers = () => {\n  for (const initializer of splitSetupInitializers) {\n    const { splitText, revealObserver, resetObserver } = initializer();\n    textRevealInstances.push({ splitText, revealObserver, resetObserver });\n  }\n  splitSetupInitializers = [];\n};\n\nconst initTextReveal = () => {\n  // Barba Js Page Transitioner Instance\n  // @ts-expect-error barbe no types\n  const barbaInstance = window.BarbaInstance;\n\n  // Select all elements with a data-reveal-type attribute (chars, words, or lines)\n  const charRevealElements = document.querySelectorAll<HTMLElement>(selectors.revealType);\n\n  // Check if page has a loader by parsing loader duration from body attribute\n  const loaderDuration = Number.parseInt(document.body.dataset.loaderDuration ?? \"\");\n  const doesLoaderExist = !Number.isNaN(loaderDuration);\n\n  const [gsap, SplitText] = getGsap([\"SplitText\"]);\n\n  if (!gsap) {\n    console.error(\n      \"GSAP is not imported. GSAP Script must be loaded before text-reveal script. Get it from here: https://gsap.com/docs/v3/Installation/?tab=cdn&module=esm&require=false&plugins=SplitText\"\n    );\n    return;\n  }\n\n  if (!SplitText) {\n    console.error(\n      \"SplitText plugin script is not imported. SplitText Script must be loaded after GSAP script and before text-reveal script. Get it from here: https://gsap.com/docs/v3/Installation/?tab=cdn&module=esm&require=false&plugins=SplitText\"\n    );\n    return;\n  }\n\n  // Process each text reveal element\n  for (let i = 0; i < charRevealElements.length; i++) {\n    // Target element to animate\n    const charRevealEl = charRevealElements[i]!;\n\n    // Find parent element for intersection observation\n    // If data-reveal-parent exists, use it, otherwise use the element itself\n    const charRevealParentEl =\n      charRevealEl.closest<HTMLElement>(selectors.revealParent) || charRevealEl;\n\n    // Extract animation configuration from data attributes\n    // These values determine how the animation will behave\n    const {\n      animationType, // Type of animation (from-bottom, from-top, fade-from-bottom-left)\n      delay, // Delay before animation starts\n      duration, // Duration of animation\n      easing, // Easing function\n      revealType, // How text is split (chars, words, lines)\n      staggerDelay, // Delay between each animated element\n      fromX, // Starting X position for fade-from-bottom-left\n      fromY, // Starting Y position for fade-from-bottom-left\n      fromOpacity, // Starting opacity for fade-from-bottom-left\n      viewThreshold, // Viewport threshold to trigger animation\n    } = getAnimationValues(charRevealEl, undefined, charRevealParentEl);\n\n    /**\n     * Determine if split text should remain split after animation\n     * Checks data-keep-split on element or closest ancestor with that attribute\n     */\n    const getKeepSplit = () => {\n      const value =\n        charRevealEl.dataset.keepSplit ||\n        charRevealEl.closest<HTMLElement>(\"[data-keep-split]\")?.dataset.keepSplit;\n\n      if (value === \"true\") return true;\n      if (value === \"false\") return false;\n\n      return false;\n    };\n\n    /**\n     * Determine if animation should reset when element leaves viewport\n     * Checks data-reset-animation on element or closest ancestor with that attribute\n     */\n    const getResetAnimation = () => {\n      const value =\n        charRevealEl.dataset.resetAnimation ||\n        charRevealEl.closest<HTMLElement>(\"[data-reset-animation]\")?.dataset.resetAnimation;\n\n      if (value === \"true\") return true;\n      if (value === \"false\") return false;\n\n      return false;\n    };\n\n    const keepSplit = getKeepSplit();\n    const shouldAnimationReset = getResetAnimation();\n\n    // Animation properties for initial (hidden) and final (visible) states\n    const initialAnimationProps: GSAPTweenVars = {};\n    const finalAnimationProps: GSAPTweenVars = {};\n\n    // Configure animation properties based on animation type\n    if (animationType === \"from-bottom\") {\n      // Start below and animate up\n      initialAnimationProps.y = \"100%\";\n      finalAnimationProps.y = \"0%\";\n    } else if (animationType === \"from-top\") {\n      // Start above and animate down\n      initialAnimationProps.y = \"-100%\";\n      finalAnimationProps.y = \"0%\";\n    } else if (animationType === \"fade-from-bottom-left\") {\n      // Start from bottom-left with fade-in\n      initialAnimationProps.y = fromY || \"30%\";\n      initialAnimationProps.x = fromX || \"-50px\";\n      initialAnimationProps.opacity = fromOpacity || \"0.05\";\n\n      finalAnimationProps.y = \"0%\";\n      finalAnimationProps.x = \"0%\";\n      finalAnimationProps.opacity = \"1\";\n    }\n\n    // Add common animation properties\n    finalAnimationProps.delay = delay;\n    finalAnimationProps.duration = duration;\n    finalAnimationProps.ease = easing;\n    finalAnimationProps.stagger = staggerDelay;\n\n    // References to store created GSAP and SplitText instances\n    let ctx: ReturnType<GSAPType[\"context\"]> | undefined = undefined;\n    let tl: Timeline | undefined = undefined;\n    let splitter: globalThis.SplitText | undefined = undefined;\n    let splittedElements: Element[] | undefined = undefined;\n\n    /**\n     * Clean up GSAP timeline and context\n     */\n    const destroyTimeline = () => {\n      if (tl) {\n        tl.revert();\n        tl = undefined;\n      }\n      if (ctx) {\n        ctx.revert();\n        ctx = undefined;\n      }\n    };\n\n    /**\n     * Create GSAP timeline for the animation\n     */\n    const initTimeline = () => {\n      ctx = gsap.context(() => {\n        // Create paused timeline - will be played when element enters viewport\n        tl = gsap.timeline({ paused: true });\n\n        // Set initial state (hidden)\n        tl.set(splittedElements!, initialAnimationProps).add(\"start\");\n\n        // Animate to final state (visible)\n        tl.to(splittedElements!, finalAnimationProps).add(\"end\");\n\n        // Set tiny progress to ensure initial state is applied\n        tl.progress(0.001);\n      });\n    };\n\n    /**\n     * Reset animation by destroying timeline and reverting split text\n     */\n    const resetSplitAnimation = () => {\n      destroyTimeline();\n      splitter?.revert();\n\n      // Fix layout shift for line animations\n      if (revealType === \"lines\" && !keepSplit) {\n        fixLineLayoutShiftAfterRevert();\n      }\n    };\n\n    /**\n     * Fix layout shift for line animations by setting width before splitting\n     * This prevents content jumps when text is split into lines\n     * Uses getBoundingClientRect() to get precise decimal pixel values instead of\n     * offsetWidth which rounds down to integers\n     */\n    const fixLineLayoutShiftBeforeSplit = () => {\n      // Get exact width with decimal precision\n      const rect = charRevealEl.getBoundingClientRect();\n      const charRevealElWidth = rect.width + \"px\";\n\n      charRevealEl.style.minWidth = charRevealElWidth;\n    };\n\n    /**\n     * Remove fixed width after animation reverts\n     */\n    const fixLineLayoutShiftAfterRevert = () => {\n      charRevealEl.style.removeProperty(\"min-width\");\n    };\n\n    /**\n     * Create SplitText instance and configure it based on animation settings\n     */\n    const getSplitter = () => {\n      // Fix layout issues for line animations\n      if (revealType === \"lines\" && !keepSplit) {\n        wrapHyphenatedWords(charRevealEl);\n        fixLineLayoutShiftBeforeSplit();\n      }\n\n      const splitter = SplitText.create(charRevealEl, {\n        // For char animations, we need to split into words first, then chars\n        type: revealType === \"chars\" ? \"words, chars\" : revealType,\n        // To make lines responsive\n        autoSplit: revealType === \"lines\",\n        // Only use masks for from-top/from-bottom animations (not for fade animations)\n        mask:\n          animationType === \"fade-from-bottom-left\"\n            ? undefined\n            : revealType === \"chars\"\n              ? \"words\"\n              : revealType,\n        // To make sure chars wont break\n        smartWrap: revealType === \"chars\",\n        // CSS classes for split elements\n        charsClass: \"split-chars\",\n        wordsClass: \"split-words\",\n        linesClass: \"split-lines\",\n        // Initialize timeline when on split\n        onSplit: (split) => {\n          splittedElements = split[revealType];\n          initTimeline();\n        },\n      });\n\n      // Mark element as initialized so CSS can show it\n      // Works with CSS: [data-reveal-type]:not([data-initialized]) { visibility: hidden; }\n      charRevealEl.setAttribute(\"data-initialized\", \"\");\n      return splitter;\n    };\n\n    /**\n     * Handle element entering viewport - play animation\n     */\n    const onEnter = () => {\n      if (!tl) return;\n\n      // Play animation and clean up after if not keeping split text\n      tl.restart(true).then(() => {\n        if (keepSplit) return;\n        resetSplitAnimation();\n      });\n    };\n\n    /**\n     * Handle element leaving viewport - reset for animations that should restart\n     */\n    const onLeave = () => {\n      if (!shouldAnimationReset) return;\n\n      resetSplitAnimation();\n      // Recreate split text when element leaves viewport\n      splitter = getSplitter();\n    };\n\n    /**\n     * Set up split text and intersection observers\n     */\n    const initSplitSetup = () => {\n      // Create initial split text setup\n      splitter = getSplitter();\n\n      // Create observer to detect when element enters viewport\n      const revealObserver = new IntersectionObserver(\n        (entries) => {\n          for (const entry of entries) {\n            if (entry.isIntersecting) {\n              onEnter();\n              // If animation doesn't restart, we don't need to observe anymore\n              if (shouldAnimationReset) return;\n              revealObserver.unobserve(entry.target);\n            }\n          }\n        },\n        {\n          threshold: viewThreshold, // How much of element must be visible\n        }\n      );\n      revealObserver.observe(charRevealParentEl);\n\n      let resetObserver: IntersectionObserver | undefined = undefined;\n\n      // For restart animations, create observer to detect when element leaves viewport\n      if (shouldAnimationReset) {\n        resetObserver = new IntersectionObserver(\n          (entries) => {\n            for (const entry of entries) {\n              if (entry.isIntersecting) return;\n              onLeave();\n            }\n          },\n          {\n            threshold: 0,\n          }\n        );\n        resetObserver.observe(charRevealParentEl);\n      }\n\n      return {\n        splitText: splitter,\n        revealObserver,\n        resetObserver,\n      };\n    };\n\n    splitSetupInitializers.push(initSplitSetup);\n  }\n\n  // Initialize based on whether page has a loader\n  if (barbaInstance) {\n    barbaInstance.hooks.afterOnce(() => {\n      document.fonts.ready.then(() => {\n        executeSplitSetupInitializers();\n      });\n    });\n  } else if (doesLoaderExist) {\n    // If page has loader, wait for both loader and fonts before initializing\n    window.addEventListener(\"load\", async () => {\n      const fontsReadyPromise = document.fonts.ready;\n      const loaderPromise = wait(loaderDuration);\n      await Promise.all([fontsReadyPromise, loaderPromise]);\n      executeSplitSetupInitializers();\n    });\n  } else {\n    // Otherwise just wait for fonts to be ready\n    document.fonts.ready.then(() => {\n      executeSplitSetupInitializers();\n    });\n  }\n};\n\nconst destroyTextReveal = () => {\n  for (const instance of textRevealInstances) {\n    if (instance.splitText) {\n      instance.splitText.revert();\n      instance.splitText = undefined;\n    }\n    if (instance.revealObserver) {\n      instance.revealObserver.disconnect();\n      instance.revealObserver = undefined;\n    }\n    if (instance.resetObserver) {\n      instance.resetObserver.disconnect();\n      instance.resetObserver = undefined;\n    }\n  }\n  textRevealInstances = [];\n};\n\nafterWebflowReady(() => {\n  initTextReveal();\n\n  addWFCustomPageLoadFeature({\n    name: \"TEXT_REVEAL_ANIMATION\",\n    async: false,\n    init: initTextReveal,\n    destroy: destroyTextReveal,\n    reInit: () => {\n      destroyTextReveal();\n      initTextReveal();\n    },\n  });\n});\n"],
  "mappings": "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",
  "names": ["splitter"]
}
